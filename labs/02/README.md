# Лабораторная работа №2

- [Лабораторная работа №2](#лабораторная-работа-2)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — list-processes-win — 50 баллов](#задание-1--list-processes-win--50-баллов)
      - [Требования](#требования-1)
      - [Дополнительные условия](#дополнительные-условия)
      - [Бонус +10 баллов за вывод использования процессорного времени](#бонус-10-баллов-за-вывод-использования-процессорного-времени)
      - [Бонус +10 баллов за вывод количества потоков в процессе](#бонус-10-баллов-за-вывод-количества-потоков-в-процессе)
      - [Бонус +10 баллов за вывод командной строки, с которой был запущен процесс](#бонус-10-баллов-за-вывод-командной-строки-с-которой-был-запущен-процесс)
      - [Практическая часть](#практическая-часть)
      - [Подсказки](#подсказки)
    - [Задание 2 — list-processes-linux — 50 баллов](#задание-2--list-processes-linux--50-баллов)
      - [Требования](#требования-2)
      - [Дополнительные условия](#дополнительные-условия-1)
      - [Бонус +10 баллов за вывод % использования CPU](#бонус-10-баллов-за-вывод--использования-cpu)
      - [Бонус +10 баллов за вывод количества потоков](#бонус-10-баллов-за-вывод-количества-потоков)
      - [Бонус +10 баллов за вывод командной строки, с которой был запущен процесс](#бонус-10-баллов-за-вывод-командной-строки-с-которой-был-запущен-процесс-1)
      - [Практическая часть](#практическая-часть-1)
      - [Подсказки](#подсказки-1)
    - [Задание 3 — zombie — 30 баллов](#задание-3--zombie--30-баллов)
      - [Подсказки](#подсказки-2)
    - [Задание 4 — flip-case — 80 баллов](#задание-4--flip-case--80-баллов)
      - [Что программа должна делать](#что-программа-должна-делать)
      - [Требования к реализации](#требования-к-реализации)
      - [Интерфейс командной строки](#интерфейс-командной-строки)
      - [Мини-пример](#мини-пример)
      - [Подсказки](#подсказки-3)
    - [Задание 5 — exe-packer — 120 баллов](#задание-5--exe-packer--120-баллов)
      - [Требования к реализации](#требования-к-реализации-1)
      - [Подсказки](#подсказки-4)
  - [Ссылки](#ссылки)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 180 баллов.
- На оценку хорошо нужно набрать не менее 240 баллов.
- Для получения оценки "отлично" нужно набрать не менее 300 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — list-processes-win — 50 баллов

Напишите консольную программу **list-processes-win** для ОС Windows,
которая выводит информацию о запущенных в настоящий момент процессах.

#### Требования

В выводе должна присутствовать следующая информация:

- **PID** процесса
- **имя исполняемого файла**
- **имя пользователя**, от которого запущен процесс
- **объём потребляемой памяти** (раздельно: *Private Bytes* и *Shared Memory*)

Вывод должен быть **отсортирован по объёму потребляемой памяти** (по убыванию).
В конце отчёта должна выводиться **сводная статистика**:

- общее количество процессов
- суммарный объём private и shared памяти

#### Дополнительные условия

- Информацию о процессах необходимо получать с использованием **Windows API**
  (например, `EnumProcesses`, `OpenProcess`, `GetProcessMemoryInfo`, `QueryFullProcessImageName`).
- Программа должна корректно обрабатывать ситуации, когда доступ к информации о том или ином процессе запрещён.
  В этом случае следует вывести сообщение об ошибке вместо данных для такого процесса.
- Для управления ресурсами используйте **RAII-обёртки для HANDLE**.

#### Бонус +10 баллов за вывод использования процессорного времени

Вывести столбец **% CPU** за последнюю секунду для каждого процесса.

#### Бонус +10 баллов за вывод количества потоков в процессе

Добавить в таблицу столбец **#Threads**.

#### Бонус +10 баллов за вывод командной строки, с которой был запущен процесс

Вывести столбец **CMD** с указанием полного пути и параметров командной строки

#### Практическая часть

1. Сравните вывод вашей программы с данными в **Task Manager**. Совпадают ли результаты?
2. Запустите программу от имени **обычного пользователя** и от имени **администратора**.
   Опишите, какие процессы становятся недоступными.

#### Подсказки

- Для работы с процессами используйте заголовки `<windows.h>`, `<psapi.h>`, `<tlhelp32.h>`.
- Для получения имени пользователя может потребоваться `OpenProcessToken` и `LookupAccountSid`.
- Для CPU% можно использовать `GetProcessTimes` в комбинации с измерением интервала времени.
- Для командной строки — `QueryFullProcessImageName` или `CommandLineToArgvW` (через `NtQueryInformationProcess`).

### Задание 2 — list-processes-linux — 50 баллов

Напишите консольную программу **list-processes-linux** для ОС Linux,
которая выводит информацию о запущенных в настоящий момент процессах.

#### Требования

В выводе по каждому процессу должна присутствовать следующая информация:

- **PID** процесса
- **имя исполняемого файла** (basename; можно брать по ссылке `/proc/<pid>/exe`)
- **имя пользователя**, от которого запущен процесс
- **объём потребляемой памяти** раздельно:
  - **Private** (приватная память процесса)
  - **Shared** (разделяемая память)

Вывод должен быть **отсортирован по объёму памяти (Private + Shared)** по убыванию.
В конце отчёта вывести **сводную статистику**:

- общее количество процессов
- суммарный объём **Private** и **Shared** памяти по всем процессам

#### Дополнительные условия

- Источником данных должен быть **/proc**:

  - имя исполняемого файла: `/proc/<pid>/exe` (симлинк) или `/proc/<pid>/comm`
  - пользователь: UID из `/proc/<pid>/status` → преобразовать в имя через `getpwuid(3)`
  - память:

    - предпочтительно использовать `/proc/<pid>/smaps_rollup` (поля `Private_Clean/Dirty`, `Shared_Clean/Dirty`) и суммировать:
      - `Private = Private_Clean + Private_Dirty`
      - `Shared  = Shared_Clean + Shared_Dirty`
    - если `smaps_rollup` недоступен (старые ядра/права), допустимо fallback:
      - из `/proc/<pid>/status` взять `RssAnon` (условно ближе к private) и `RssFile`/`RssShmem` (shared),
      с явным указанием, что это **оценка**
  - командная строка: `/proc/<pid>/cmdline` (аргументы разделены `'\0'`)
  - число потоков: поле `Threads` в `/proc/<pid>/status` (или количество директорий в `/proc/<pid>/task`)
- Отработать типичные ошибки: процесс может исчезнуть между чтениями,
  некоторые файлы могут быть недоступны → аккуратные сообщения и пропуск, без аварийного завершения.
- Вывод оформить в виде **таблицы с выравниванием колонок**;
  единицы измерения — KiB/MiB (читаемо).
- Использовать безопасное управление ресурсами (RAII для файловых дескрипторов/`DIR*`/`FILE*`),
  проверять коды ошибок.

#### Бонус +10 баллов за вывод % использования CPU

Вывести столбец **% CPU** за последнюю секунду для каждого процесса.

Подсказка: дважды (с интервалом \~1s) прочитать:

- у процесса: `/proc/<pid>/stat` поля `utime+stime` (тик-и)
- у системы: `/proc/stat` суммарные тик-и по всем CPU
- CPU% процесса ≈ `Δ(utime+stime) / Δ(total_jiffies) * 100 * Ncpu`

#### Бонус +10 баллов за вывод количества потоков

Добавить в таблицу столбец **#Threads**.

#### Бонус +10 баллов за вывод командной строки, с которой был запущен процесс

Вывести столбец **CMD** с указанием полного пути и параметров командной строки

#### Практическая часть

1. Сравните вывод вашей программы с командами **`ps -eo pid,comm,rss`**, **`top`** и
   (если доступно) данными из **`smaps_rollup`**. Совпадают ли порядки величин?
2. Запустите программу от обычного пользователя и с повышенными привилегиями.
   Опишите, какая информация становится недоступной без root и как это влияет на точность.

#### Подсказки

- Память в `/proc` обычно указывается в **KiB**. Преобразуйте единицы и аккуратно суммируйте.
- `smaps_rollup` доступен на современных ядрах и сильно упрощает задачу подсчёта **Private/Shared**.
  Если его нет — явно пометьте вывод как «оценка».
- `readlink("/proc/<pid>/exe")` даёт путь до бинаря; basename — это «имя исполняемого файла».
  Если `exe` недоступен, используйте `/proc/<pid>/comm`.
- При чтении `/proc/<pid>/cmdline` учитывайте нулевые байты (`'\0'`) между аргументами.
- Процессы могут исчезать между итерациями — это нормально. Обрабатывайте `ENOENT` и продолжайте.
- Для форматирования таблиц задайте фиксированные ширины колонок и человекочитаемые единицы (напр., `123.4 MiB`).

### Задание 3 — zombie — 30 баллов

Ознакомьтесь с работой системных вызовов [`fork`](https://man7.org/linux/man-pages/man2/fork.2.html)
и [`waitpid`](https://man7.org/linux/man-pages/man2/wait.2.html) в ОС Linux.

Напишите программу **zombie**, которая демонстрирует поведение процесса-зомби:

1. **Порождает дочерний процесс** с помощью `fork()`.

    - Дочерний процесс должен вывести свой PID и немедленно завершить работу.
    - После завершения он остаётся в состоянии **zombie**, пока родитель его не «подберёт» с помощью `waitpid()`.

2. **Родительский процесс**:

    - Выводит PID дочернего процесса.
    - Запрашивает у пользователя PID и пытается дождаться завершения работы дочернего с помощью `waitpid(pid, ...)`.
    - Если пользователь указал неверный PID и `waitpid()` вернул ошибку, программа должна запросить PID повторно.

3. **Усложнение задачи**:

   - Измените программу так, чтобы **дочерний процесс больше не печатал свой PID**.
   - Родительский процесс должен определять PID с помощью системных утилит и успешно завершать работу.

4. **Второй терминал**:

   - Используйте команды [`ps`](https://man7.org/linux/man-pages/man1/ps.1.html) и [`top`](https://man7.org/linux/man-pages/man1/top.1.html),
     чтобы увидеть зомби-процесс в списке и определить его PID.
   - Обратите внимание, что такие процессы имеют состояние `Z` (Zombie).

#### Подсказки

- Узнать PID процесса можно функцией [`getpid`](https://man7.org/linux/man-pages/man2/getpid.2.html).
- Зомби остаётся в системе до тех пор, пока родитель не вызовет `wait()` или `waitpid()`.
- Проверьте вывод `ps -el`, чтобы увидеть процесс с состоянием `Z`.
- Чтобы отладить работу, можно сначала включить вывод PID в дочернем процессе, а затем убрать его.

### Задание 4 — flip-case — 80 баллов

Ознакомьтесь с системным вызовом [`fork`](https://man7.org/linux/man-pages/man2/fork.2.html) в ОС Linux.
Напишите консольное приложение **`flip-case`**, которое для каждого переданного файла создаёт дочерний процесс и
записывает копию этого файла с инвертированным регистром **английских букв ASCII**.

#### Что программа должна делать

- Принимает произвольное число путей к файлам:

  ```bash
  flip-case input1.txt input2.txt ...
  ```

- Для **каждого** файла создаёт **отдельный дочерний процесс** (`fork()`).
- Каждый дочерний процесс:
  - печатает строку: `Process <pid> is processing <in>` (перед началом работы);
  - читает входной файл и пишет в выходной **<in>.out**, меняя регистр **только** для `A–Z` ↔ `a–z` (ASCII).
    Все остальные байты копируются без изменений (включая UTF-8—байты, двоичные данные).
  - по завершении печатает: `Process <pid> has finished writing to <in>.out`.
- Родитель:
  - **дожидается всех** дочерних процессов (цикл `waitpid(-1, ...)` с обработкой `EINTR`);
  - на каждое завершение ребёнка печатает: `Child process <pid> is over`.

#### Требования к реализации

- **Ввод/вывод**:
  - Используйте **буферизованный** I/O (чтение блоками, например 64 KiB) и преобразование регистра в памяти;
    не делайте системные вызовы «по одному байту».
  - Режим обработки — строго **байтовый** (ASCII), без локали/`isupper`/`tolower` (во избежание влияния локали). Инвертировать:
    - `a..z` → `A..Z` : `c - 'a' + 'A'`
    - `A..Z` → `a..z` : `c - 'A' + 'a'`
- **Файлы**:
  = Имя выходного: `<input>.out` в том же каталоге.
  - Если выходной уже существует — **перезаписать** (явно зафиксируйте это в help-выводе).
  - Создавайте выходной файл с правами `0644`.
- **Надёжность**:
  - На **каждый** системный вызов (open/read/write/close/fork/waitpid) проверяйте ошибки; печатайте понятные сообщения (с `strerror(errno)`).
  - Родитель не должен падать, если какой-то ребёнок завершился с ошибкой.
  - Корректно обрабатывайте ситуацию, когда файл не существует/нет прав на чтение.
- **Процессы**:
  - Порождайте столько детей, сколько входных файлов, но одновременно не больше некоторого разумного количества.
  - В родителе используйте `waitpid(-1, &status, 0)` до тех пор, пока не соберёте всех. Обрабатывайте `EINTR`.
  - В дочернем процессе завершайтесь через `std::_Exit(…)` или `_exit(…)` (чтобы не удвоить буферизованный вывод родителя).
- **Вывод**:
  - Строки статуса (выше) — по одной строке без дополнительного форматирования.
  - Разрешается межперемешивание строк от разных процессов.

#### Интерфейс командной строки

- Если аргументов нет — вывести краткую справку и код возврата `2`.
- Коды возврата:
  - `0` — все файлы успешно обработаны;
  - `1` — были ошибки (один или более файлов не обработаны);
  - `2` — ошибка использования (нет аргументов и т. п.).

#### Мини-пример

```bash
flip-case input1.txt input2.txt
```

```txt
Process 82372 is processing input1.txt
Process 82373 is processing input2.txt
Process 82373 has finished writing to input2.txt.out
Child process 82373 is over
Process 82372 has finished writing to input1.txt.out
Child process 82372 is over
```

#### Подсказки

- Эффективный цикл преобразования: читать `read()` большими блоками
  → пробегать по буферу и менять регистр только у диапазонов ASCII
  → `write()` тем же размером (учитывать частичные записи).
- Для надёжного ожидания всех детей: пока `waitpid(-1, &st, 0)`
  не вернёт `-1` с `ECHILD`. Игнорируйте `EINTR` (повтор).
- Сообщения об ошибках печатайте в `stderr`.

### Задание 5 — exe-packer — 120 баллов

Напишите консольное приложение **exe-packer** (для **Linux** или **Windows** — по выбору), которое работает в двух режимах:

1. **Режим создания архива**
   Если приложение запущено *как обычная программа* (без дописанного payload):
   - принимает на вход два аргумента:
     1. путь к исполняемому файлу (который нужно упаковать);
     2. путь к выходному самораспаковывающемуся файлу.
   - сжимает указанный исполняемый файл (например, с помощью zlib, LZ4, libbz2 или другой библиотеки).
   - создаёт копию самого себя и дописывает к ней сжатые данные как **payload**
     (например, в конец файла или в выделенную секцию данных).
   - на выходе получается единый исполняемый файл, который можно запускать.

2. **Режим распаковки и выполнения**
   Если приложение запущено *как самораспаковывающийся архив* (т.е. у него есть payload):

   - определяет наличие и размер дописанного блока сжатых данных;
   - распаковывает payload во временный файл (например, в `/tmp` под Linux или `%TEMP%` в Windows);
   - запускает этот временный исполняемый файл, передавая ему **аргументы командной строки**,
     а также наследуя **stdin, stdout, stderr**;
   - после завершения работы вложенного процесса временный файл должен быть удалён.

#### Требования к реализации

- **Автодетекция режима работы**:

  - Если payload отсутствует → программа работает как «создатель».
  - Если payload присутствует → программа работает как «распаковщик».

- **Сжатие данных**:

  - допустимо использовать любую библиотеку для сжатия (zlib, zstd, LZMA и т.д.);
  - в качестве упрощённого варианта разрешается просто сохранять данные без сжатия.

- **Формат payload**:

  - рекомендуется сохранять служебный заголовок: размер исходного файла, размер сжатого блока, сигнатуру.
  - сигнатура нужна для корректного определения наличия payload.

- **Запуск программы**:

  - под Linux: `fork + execve`, `waitpid`;
  - под Windows: `CreateProcess`, ожидание завершения через `WaitForSingleObject`.

- **Очистка временных файлов**:

  - при нормальном завершении — удалить;
  - учесть, что удаление может не произойти в случае аварийного завершения.

#### Подсказки

- **Linux**:

  - payload можно добавить простым `cat sfx-builder payload > sfx`.
  - для запуска используйте `fork()` + `execve()`.
  - временный файл создавайте через `mkstemp()`.

- **Windows**:

  - временный файл создаётся через `GetTempPath + GetTempFileName`.
  - запуск через `CreateProcess`, с передачей аргументов командной строки.

- **Определение payload**:

  - можно хранить в конце исполняемого файла сигнатуру (например, `"SFX!"`) и заголовок с размером.
  - при запуске программа проверяет последние байты своего файла.
  - Исполняемый файл должен получаться рабочим вне зависимости от того, для 32 или 64 бит было собрано приложение.

## Ссылки

- [Создание процессов с помощью вызова fork](https://www.opennet.ru/docs/RUS/linux_parallel/node7.html)
- [Windows Process Status API](https://learn.microsoft.com/en-us/windows/win32/api/_psapi/)
- [Linux /proc filesystem](https://docs.kernel.org/filesystems/proc.html)
