# Лабораторная работа №4

- [Лабораторная работа №4](#лабораторная-работа-4)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание №1 — Многопоточная поисковая система по текстовым документам — 300 баллов](#задание-1--многопоточная-поисковая-система-по-текстовым-документам--300-баллов)
      - [Требования к окружению](#требования-к-окружению)
      - [Формат запуска и режим работы](#формат-запуска-и-режим-работы)
      - [Поддерживаемые команды](#поддерживаемые-команды)
        - [1) Добавление файла в индекс](#1-добавление-файла-в-индекс)
        - [2) Добавление всех файлов из каталога](#2-добавление-всех-файлов-из-каталога)
      - [3) Рекурсивное добавление из каталога](#3-рекурсивное-добавление-из-каталога)
        - [4) Поиск](#4-поиск)
        - [5) Пакетный поиск](#5-пакетный-поиск)
        - [6) Удаление файла из индекса](#6-удаление-файла-из-индекса)
        - [7) Удаление каталога из индекса](#7-удаление-каталога-из-индекса)
        - [8) Рекурсивное удаление из индекса](#8-рекурсивное-удаление-из-индекса)
      - [Что считается «словом» и как парсить текст](#что-считается-словом-и-как-парсить-текст)
      - [Структура данных](#структура-данных)
      - [Параллелизм и синхронизация](#параллелизм-и-синхронизация)
      - [Модель запроса и ранжирование](#модель-запроса-и-ранжирование)
        - [Логика соответствия](#логика-соответствия)
        - [TF-IDF (базовая формула)](#tf-idf-базовая-формула)
      - [Производительность (ориентиры, не жёсткие требования)](#производительность-ориентиры-не-жёсткие-требования)
      - [Обработка ошибок и формат сообщений](#обработка-ошибок-и-формат-сообщений)
        - [Успех](#успех)
        - [Ошибки (стандартный поток вывода допустим)](#ошибки-стандартный-поток-вывода-допустим)
      - [Ограничения и допущения](#ограничения-и-допущения)
      - [Рекомендации](#рекомендации)
      - [Контрольные вопросы (для защиты)](#контрольные-вопросы-для-защиты)
      - [Бонус оценку производительности — 50 баллов](#бонус-оценку-производительности--50-баллов)
    - [Задание 2 — Пул потоков — 60 баллов](#задание-2--пул-потоков--60-баллов)
      - [Бонус за анализ производительности пула потоков — 20 баллов](#бонус-за-анализ-производительности-пула-потоков--20-баллов)
    - [Задание 3 — Потокобезопасная очередь — 120 баллов](#задание-3--потокобезопасная-очередь--120-баллов)
      - [Окружение](#окружение)
      - [Требования к API](#требования-к-api)
        - [Конструкторы](#конструкторы)
        - [Методы](#методы)
        - [Поведение](#поведение)
        - [Подсказки по реализации](#подсказки-по-реализации)
      - [Гарантии корректности и исключений](#гарантии-корректности-и-исключений)
      - [Примеры использования](#примеры-использования)
      - [Тестирование](#тестирование)
        - [Обязательные модульные тесты (примерные кейсы)](#обязательные-модульные-тесты-примерные-кейсы)
      - [Бонус за анализ производительности — 50 баллов](#бонус-за-анализ-производительности--50-баллов)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее X баллов.
- На оценку хорошо нужно набрать не менее Y баллов.
- Для получения оценки "отлично" нужно набрать не менее Z баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание №1 — Многопоточная поисковая система по текстовым документам — 300 баллов

Спроектировать и реализовать консольное приложение, которое индексирует текстовые файлы на диске и
выполняет быстрый полнотекстовый поиск по ним. Индексация и поиск должны уметь выполняться параллельно.

#### Требования к окружению

- Язык реализации: **C++17/20/23**.
- ОС: Linux/macOS/Windows.
- Разрешено использовать стандартную библиотеку и пул потоков (собственный или, например, `boost::asio::thread_pool`).
- Хранение индекса — **в памяти** процесса (персистентность не требуется).

#### Формат запуска и режим работы

После запуска программа переходит в **интерактивный режим** (REPL, Read-Evaluate-Print Loop):
считывает команды со stdin и печатает ответы в stdout. Каждая команда — на отдельной строке. Пустые строки игнорируются.

#### Поддерживаемые команды

##### 1) Добавление файла в индекс

```txt
add_file PATH
```

Индексирует файл по пути `PATH`. Повторная индексация **того же** файла обновляет индекс.

**При индексировании** для каждого документа в памяти создаётся структура данных,
позволяющая быстро находить документы по словам.

**Метаданные документа (минимум):**

- `id` — 64-битное целое, автоинкремент;
- `path` — абсолютный или нормализованный путь;
- информация о словах документа (для инвертированного индекса).

##### 2) Добавление всех файлов из каталога

```txt
add_dir PATH
```

Индексирует **все файлы верхнего уровня** директории `PATH` (без подкаталогов).
Индексирование файлов выполняется параллельно.
Во время индексации программа должна быть способна обрабатывать другие команды с консоли.

#### 3) Рекурсивное добавление из каталога

```txt
add_dir_recursive PATH
```

Рекурсивно индексирует **все файлы** внутри `PATH` во всех подкаталогах.
Задачи индексирования распределяются по пулу потоков.
Во время индексации программа должна быть способна обрабатывать другие команды с консоли.

##### 4) Поиск

```txt
find QUERY
```

Ищет документы, **наилучшим образом соответствующие** запросу `QUERY`.
Выводит до 10 документов в порядке **убывания релевантности**. Сопоставление происходит без учёта регистра символов.
Документы, релевантность которых равна нулю, включаться в результаты поиска не должны.

Пример:

```txt
> find linux kernel mode
Search took 0.0031s:
1. id:25, relevance:3.75000, path:/home/user/docs/Linux core for dummies.txt
2. id:7824, relevance:2.11113, path:/home/user/docs/linux-vs-windows.txt
3. id:328, relevance:0.00025, path:/home/user/docs/инструкция к стиральной машине.txt
---
```

##### 5) Пакетный поиск

```txt
find_batch PATH
```

Параллельно выполняет поисковые запросы из файла `PATH` (по одному запросу в строке).
В результате для **каждого** запроса печатаются его порядковый номер
(нумерация с 1, порядок вывода — **произвольный** из-за параллелизма), сам текст запроса и результаты.

Пример:

```txt
> find_batch /home/user/requests.txt
2. query: linux kernel mode
  Search took 0.0130s:
  1. id:25, relevance:3.75000, path:/home/user/docs/Linux core for dummies.txt
  2. id:7824, relevance:2.11113, path:/home/user/docs/linux-vs-windows.txt
  3. id:328, relevance:0.00025, path:/home/user/docs/инструкция к стиральной машине.txt
  ---
1. query: Harry Potter Hermione Granger
  Search took 0.0250s:
  1. id:13, relevance:15.24300, path:/home/user/books/Harry Potter and the Philosopher's Stone.txt
  2. id:76, relevance:13.88900, path:/home/user/books/Harry Potter and the Deathly Hallows.txt
  ...
  ---
```

> Замечание: из-за параллельной обработки вторым может быть выведен результат для запроса №1 и т. д. Это **нормально**.

##### 6) Удаление файла из индекса

```txt
remove_file PATH
```

Удаляет документ по пути `PATH` из индекса. Сам файл на диске **не трогать**. Если документа нет — проигнорировать ошибку.

##### 7) Удаление каталога из индекса

```txt
remove_dir PATH
```

Удаляет из индекса **все документы верхнего уровня** каталога `PATH` (без рекурсии).
Удаление распределяется по пулу потоков. Документы, отсутствующие в индексе, **игнорируются**.

##### 8) Рекурсивное удаление из индекса

```txt
remove_dir_recursive PATH
```

Как `remove_dir`, но рекурсивно по подкаталогам.

---

#### Что считается «словом» и как парсить текст

- Документы — обычные текстовые файлы из одной или нескольких строк.
- **Слово** — последовательность из одного или более символов **английского алфавита** `[A-Za-z]+`.
- Разделители: всё, что не входит в `[A-Za-z]`, в том числе цифры, знаки препинания, пробелы и т. п.
- Регистронезависимая нормализация: приводим слова к нижнему регистру.

> Дополнительно (по желанию): поддержка Unicode/кириллицы, стоп-слова — как бонусные фичи (см. ниже).

---

#### Структура данных

Рекомендуется использовать **инвертированный индекс**, структуру данных,
которая сопоставляет слова (термины) со списком документов, в которых эти слова встречаются:

- `term -> list of (doc_id, term_frequency_in_doc, ...)`
- Дополнительно можно хранить длину документа (кол-во слов) и общее число документов.

Допускаются иные структуры, обеспечивающие эквивалентную функциональность и асимптотику.

---

#### Параллелизм и синхронизация

- Индексация нескольких файлов — **параллельна** через пул потоков.
- Поиск может выполняться **параллельно с индексированием**.
- Используйте корректные примитивы синхронизации (мьютексы/RW-мьютексы/спинлоки/атомики),
- чтобы избежать гонок и обеспечивать **видимость данных** между потоками.
- Допускается **копия слепка** (snapshot) индекса для запроса, если это упрощает и ускоряет синхронизацию.

---

#### Модель запроса и ранжирование

##### Логика соответствия

- По умолчанию используем **конъюнкцию**: документ релевантен, если содержит хотя бы одно слово из запроса.
- Сопоставление выполняется без учёта регистра символов.

##### TF-IDF (базовая формула)

Используйте **TF-IDF** для оценки релевантности:

- TF (Term Frequency, частота термина) равен частоте термина в каждом документе, где он встречается.
  - $TF(term, doc)=count(term, doc) / words\_count(doc)$, где:
    - $count(term, doc)$ — количество раз, которое $term$ встречается в документе $doc$;
    - $word\_count(doc)$ — количество слов в документе $doc$.
- IDF (Inverse Document Frequency, обратная частота документа) термина равен логарифму
отношения числа документов к количеству документов, в которых этот термин встречается.
  - $IDF(term)=log(N / df(term)$, где
    - $N$ — общее число документов,
    - $df(term)$ — число документов, содержащих $term$.
  Основание логарифма — любое фиксированное, например $e$.
- Релевантность документа запросу равна сумме произведений TF термина и документа на IDF этого термина
  - $score(doc, query) = \sum_{term\in query} TF(term, doc) * IDF(term)$
    - Документы, в которых термин отсутствует, а также термины,
    присутствующие абсолютно во всех документах (их IDF равен 0), учитываться не должны.

Допустим, есть набор документов:

|Документ|Текст|
|--------|-------|
| a.txt  | a cat is an animal|
| b.txt  | a dog is an animal too|
| c.txt  | a sparrow is a bird|

IDF (Inverse Document Frequency, обратная частота документа) термина равен логарифму
отношения числа документов к количеству документов, в которых этот термин встречается.

Рассчитаем TF-IDF для запроса «a cat».

Рассчитаем IDF для каждого из термина.

|Документ|a           |cat              |
|--------|------------|-----------------|
|a.txt   |✅         |✅              |
|b.txt   |✅         |❌              |
|c.txt   |✅         |❌              |
|**IDF** |$log(3/3)=0$|$log(3/1)=1.0986$|

Рассчитаем TF терминов запроса для каждого из документов:

|Документ|TF("a")      |TF("cat")|
|--------|-------------|---------|
|a.txt   |$1/5=0.2$    |$1/5=0.2$|
|b.txt   |$1/6=0.16667$|$0/6=0$  |
|c.txt   |$2/5=0.4$    |$0/5=0$  |

Величина TF-IDF равна произведению IDF термина на его TF в документе.
Для оценки релевантности вычисляют сумму TF-IDF по словам документа.

|Документ|TF-IDF("a")  |TF-IDF("cat")       |Релевантность      |
|--------|-------------|--------------------|-------------------|
|a.txt   |$0.2*0=0$    |$0.2*1.0986=0.01972$|$0+0.01972=0.01972$|
|b.txt   |$0.16667*0=0$|$0*1.0986=0$        |$0+0=0$            |
|c.txt   |$0.4*0=0$    |$0*1.0986=0$        |$0+0=0$            |

В итоге самым релевантным документом среди содержащих слова «a» и «cat»
будет a.txt. Так как слово "a" встречается абсолютно во всех документах,
оно не влияет на итоговую релевантность.

---

#### Производительность (ориентиры, не жёсткие требования)

- Индексация каталога из ~10 000 средних по размеру файлов должна занимать **секунды/десятки секунд**, а не минуты.
- Поиск по 1–3 словам должен выполняться ~миллисекунды на уже построенном индексе даже при тысячах файлов.
- Пул потоков — **ограниченный** (не «по потоку на файл»).

---

#### Обработка ошибок и формат сообщений

##### Успех

- Время выполнения поиска печатайте как `Search took X.XXXXs:`.
- Релевантность выводите как число с фиксированной точностью (например, `%.5f`).

##### Ошибки (стандартный поток вывода допустим)

- Файл/каталог не найден или нет доступа:

  ```txt
  error: path not found: PATH
  ```

- Пустой запрос:

  ```txt
  error: empty query
  ```

- Документ для удаления не найден:

  ```txt
  error: file not in index: PATH
  ```

- Неизвестная команда:

  ```txt
  error: unknown command
  ```

Все ошибки **не должны** приводить к падению приложения.

---

#### Ограничения и допущения

- Индекс хранится в памяти и может занимать заметный объём.
  Для оптимизации хранения строк можете использовать `string_view` и вместо слов хранить их id. 
- Кодировка — предполагается UTF-8; символы вне `[A-Za-z]` выступают разделителями.

---

#### Рекомендации

- Рекомендуется покрыть классы тестами, в том числе проверяющими работу в многопоточном режиме.
- Для облегчения написания тестов рекомендуется работать с файловой системой не напрямую, а при помощи mock-ов.
- Прогоните стресс-тест, проиндексировав большое количество (тысячи) текстовых файлов.
  Например, исходники boost. На таких объёмах данных ошибки многопоточности быстро дают о себе знать.

#### Контрольные вопросы (для защиты)

1. Чем инвертированный индекс лучше прямого индекса для поиска?
2. В чём смысл IDF? Что будет, если его убрать?
3. Как избежать гонок при одновременном индексировании и поиске?
4. Какие «узкие места» по памяти и времени у вашего решения? Как их улучшить?

#### Бонус оценку производительности — 50 баллов

Напишите бенчмарки, оценивающие время работы в следующих сценариях:

- время индексирования набора документов на разном количестве потоков
- среднее время поиска в зависимости от количества потоков

### Задание 2 — Пул потоков — 60 баллов

Разработайте класс `ThreadPool`, который создаёт заданное количество рабочих потоков,
которые параллельно извлекают задачи из очереди и выполняют их.

```c++
class ThreadPool
{
public:
    using Task = std::function<void()>;

    // Создаёт пул из numThreads рабочих потоков
    explicit ThreadPool(unsigned numThreads);

    // Копирование и присваивание объектов этого класса невозможно
    ThreadPool(const ThreadPool&) = delete;
    ThreadPool& operator=(const ThreadPool&) = delete;

    // Дожидается окончания выполнения всех задач. 
    ~ThreadPool();

    // Отправляет задачу task на выполнение в любом из фоновых потоков внутри пула.
    // Этот метод можно вызывать из любого потока, в том числе из любого потока внутри пула.
    void Dispatch(Task task);
};
```

Для тестирования класса `ThreadPool` разработайте юнит-тесты.

#### Бонус за анализ производительности пула потоков — 20 баллов

Используя один из фреймворков для написания бенчмарков (например, Google Benchmark или Catch2 benchmark),
оцените время выполнения заданного количества задач в зависимости от количества потоков.

Также сравните время работы вашего Thread Pool с реализацией ThreadPool
с открытым исходным кодом из какой-нибудь другой библиотеки (например, из Boost.Asio).
При сдаче лабораторной работы расскажите преподавателю, какие подходы используются
в исследуемой реализации, за счёт которых они показывают лучшую (или худшую производительность).

### Задание 3 — Потокобезопасная очередь — 120 баллов

Спроектировать и реализовать потокобезопасную ограничиваемую очередь `ThreadSafeQueue<T>`,
поддерживающую безопасную работу из нескольких потоков производителей и потребителей.
Очередь должна корректно работать как в ограниченном (bounded), так и в неограниченном (unbounded) режимах.

#### Окружение

- Язык: **C++20**
- ОС: Linux/macOS/Windows
- Разрешено: стандартная библиотека (`<mutex>`, `<condition_variable>`, `<deque>`, `<memory>`, `<optional>` и т. п.).
- Запрещено: готовые очереди из сторонних библиотек (folly, TBB, Boost.Lockfree и т. п.).

#### Требования к API

##### Конструкторы

```cpp
explicit ThreadSafeQueue(size_t capacity = 0);
```

- `capacity == 0` → очередь неограничена.
- `capacity  > 0` → очередь ограничена: операции вставки блокируются при заполнении.

##### Методы

```cpp
// Добавляет в конец, блокируется если очередь полна (только в bounded-режиме).
void Push(const T& value);
void Push(T&& value);

// Не блокируется: возвращает false, если очередь была полна (bounded-режим).
[[nodiscard]] bool TryPush(const T& value);
[[nodiscard]] bool TryPush(T&& value);

// Пытается изъять: false / nullptr, если пусто
bool TryPop(T& out);
std::unique_ptr<T> TryPop();

// Ждёт появления элемента и возвращает его по значению.
// Определён только если T — nothrow_move_constructible.
T WaitAndPop();  // Используйте SFINAE или static_assert для ограничения

// Ждёт появления элемента, записывает в out.
void WaitAndPop(T& out);

// Информация о состоянии.
size_t GetSize() const;
bool   IsEmpty() const;

// Потокобезопасный обмен содержимым.
void Swap(ThreadSafeQueue& other);
void Swap(std::deque<T>& other); // обменивает внутренний буфер со внешней deque
```

##### Поведение

- **Многопоточность**: Любое количество производителей и потребителей. Отсутствие дедлоков и «проглоченных» уведомлений.
  Корректная работа при **ложных пробуждениях**.
- **Ограниченная очередь**:
  - `Push` — **блокируется**, пока не освободится место.
  - `TryPush` — **не блокируется**, возвращает `false`, если нет места.
- **Неограниченная очередь**:
  - `Push` и `TryPush` всегда вставляют (если не произошло исключение из-за копирования/перемещения `T`).
- **Исключения**:
  - Минимум — **базовая гарантия** (invariants сохранены, утечек нет).
- **Сложность**: амортизированно `O(1)` на `Push/TryPush/TryPop/WaitAndPop`.

##### Подсказки по реализации

- Контейнер хранения: `std::deque<T>`.
- Синхронизация: один `std::shared_mutex` + две `std::condition_variable`:
  - `cv_not_empty` — для ожидания элемента,
  - `cv_not_full`  — для ожидания места (в bounded-режиме).
- **Порядок блокировок при Swap** двух очередей:
  - Используйте `std::scoped_lock lk(mtx_a, mtx_b);` (или **адресный порядок** для C++17), чтобы исключить дедлок.
- `Swap(std::deque<T>& other)`: блокируйте `this->mtx`, затем `std::swap(buffer_, other)`, затем сингналите обе CV при необходимости.
- Не забывайте о **ложных пробуждениях**: `wait` всегда с предикатом или в цикле.
- `GetSize()` можно делать под мьютексом либо поддерживать атомарный счётчик.

#### Гарантии корректности и исключений

- **Базовая гарантия** для всех методов: invariants класса сохраняются; при исключениях состояние очереди валидно.
- `WaitAndPop()` по значению — разрешён **только**, если `T` — `std::is_nothrow_move_constructible_v<T> == true`.
- Иначе — ошибка ошибка компиляции с внятным сообщением.
- **Отсутствие дедлоков**:
  - Не блокируйте `Push/TryPush` навсегда в unbounded-режиме.
  - В bounded-режиме `Push` должен разблокироваться, когда потребитель извлёк элемент и подал сигнал.

#### Примеры использования

```cpp
ThreadSafeQueue<int> q(2); // bounded на 2 элемента

std::jthread prod([&]{
  for (int i = 0; i < 10; ++i) q.Push(i);
});

std::jthread cons([&]{
  for (int i = 0; i < 10; ++i) {
    int x = q.WaitAndPop();
    // обработка x
  }
});

prod.join();
cons.join();
```

#### Тестирование

##### Обязательные модульные тесты (примерные кейсы)

1. **Базовые операции (single-thread)**

   - `TryPop` на пустой → `false`/`nullptr`.
   - `Push` + `TryPop` возвращает то же значение (копия/перемещение).
   - `GetSize/IsEmpty` корректны.
2. **Bounded семантика**

   - `capacity=1`: второй `TryPush` → `false`.
   - `Push` блокируется, пока другой поток не выполнит `TryPop/WaitAndPop`.
3. **Unbounded семантика**

   - `capacity=0`: последовательные `Push` не блокируются; порядок FIFO сохраняется.
4. **Параллельность MPMC**

   - N производителей, M потребителей; суммарно вставлено K элементов; все K извлечены и без потерь/дубликатов .
5. **Spurious wakeups**

   - Стресс-тест ожиданий (`WaitAndPop`), чтобы убедиться, что предикаты корректны.
6. **Исключения из копирования/перемещения T**

   - Специальный тип-«бомба», бросающий при копировании (или аллокации через счётчик). Очередь остаётся в валидном состоянии.
7. **Swap(ThreadSafeQueue&)**

   - Перестановка содержимого двух очередей (в т. ч. разных `capacity`).
     Нет дедлоков при 2 потоках, одновременно меняющих очереди.
8. **Swap(std::deque\<T\>&)**

   - Буфер обменялся, размеры/пустота корректны, уведомления поданы (после swap можно `Push`/`WaitAndPop`).

#### Бонус за анализ производительности — 50 баллов

Напишите бенчмарки, проверяющие время работы bounded и unbounded очереди
на разных количествах Producer и Consumer threads.

Сравните поведение на аналогичных сценариях с одной из open-source реализацией MPMC
очереди из популярных библиотек (например, `boost::lockfree::queue`).
Изучите код альтернативной реализации и сделайте выводы насчёт причин различий в производительности.

