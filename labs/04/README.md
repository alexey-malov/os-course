# Лабораторная работа №4

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее X баллов.
- На оценку хорошо нужно набрать не менее Y баллов.
- Для получения оценки "отлично" нужно набрать не менее Z баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание №1 — Многопоточная поисковая система по текстовым документам — 300 баллов

Спроектировать и реализовать консольное приложение, которое индексирует текстовые файлы на диске и
выполняет быстрый полнотекстовый поиск по ним. Индексация и поиск должны уметь выполняться параллельно.

#### Требования к окружению

- Язык реализации: **C++17/20/23**.
- ОС: Linux/macOS/Windows.
- Разрешено использовать стандартную библиотеку и пул потоков (собственный или, например, `boost::asio::thread_pool`).
- Хранение индекса — **в памяти** процесса (персистентность не требуется).

#### Формат запуска и режим работы

После запуска программа переходит в **интерактивный режим** (REPL, Read-Evaluate-Print Loop):
считывает команды со stdin и печатает ответы в stdout. Каждая команда — на отдельной строке. Пустые строки игнорируются.

#### Поддерживаемые команды

##### 1) Добавление файла в индекс

```txt
add_file PATH
```

Индексирует файл по пути `PATH`. Повторная индексация **того же** файла обновляет индекс.

**При индексировании** для каждого документа в памяти создаётся структура данных,
позволяющая быстро находить документы по словам.

**Метаданные документа (минимум):**

- `id` — 64-битное целое, автоинкремент;
- `path` — абсолютный или нормализованный путь;
- информация о словах документа (для инвертированного индекса).

##### 2) Добавление всех файлов из каталога

```txt
add_dir PATH
```

Индексирует **все файлы верхнего уровня** директории `PATH` (без подкаталогов).
Индексирование файлов выполняется параллельно.
Во время индексации программа должна быть способна обрабатывать другие команды с консоли.

#### 3) Рекурсивное добавление из каталога

```txt
add_dir_recursive PATH
```

Рекурсивно индексирует **все файлы** внутри `PATH` во всех подкаталогах.
Задачи индексирования распределяются по пулу потоков.
Во время индексации программа должна быть способна обрабатывать другие команды с консоли.

##### 4) Поиск

```txt
find QUERY
```

Ищет документы, **наилучшим образом соответствующие** запросу `QUERY`.
Выводит до 10 документов в порядке **убывания релевантности**. Сопоставление происходит без учёта регистра символов.
Документы, релевантность которых равна нулю, включаться в результаты поиска не должны.

Пример:

```txt
> find linux kernel mode
Search took 0.0031s:
1. id:25, relevance:3.75000, path:/home/user/docs/Linux core for dummies.txt
2. id:7824, relevance:2.11113, path:/home/user/docs/linux-vs-windows.txt
3. id:328, relevance:0.00025, path:/home/user/docs/инструкция к стиральной машине.txt
---
```

##### 5) Пакетный поиск

```txt
find_batch PATH
```

Параллельно выполняет поисковые запросы из файла `PATH` (по одному запросу в строке).
В результате для **каждого** запроса печатаются его порядковый номер
(нумерация с 1, порядок вывода — **произвольный** из-за параллелизма), сам текст запроса и результаты.

Пример:

```txt
> find_batch /home/user/requests.txt
2. query: linux kernel mode
  Search took 0.0130s:
  1. id:25, relevance:3.75000, path:/home/user/docs/Linux core for dummies.txt
  2. id:7824, relevance:2.11113, path:/home/user/docs/linux-vs-windows.txt
  3. id:328, relevance:0.00025, path:/home/user/docs/инструкция к стиральной машине.txt
  ---
1. query: Harry Potter Hermione Granger
  Search took 0.0250s:
  1. id:13, relevance:15.24300, path:/home/user/books/Harry Potter and the Philosopher's Stone.txt
  2. id:76, relevance:13.88900, path:/home/user/books/Harry Potter and the Deathly Hallows.txt
  ...
  ---
```

> Замечание: из-за параллельной обработки вторым может быть выведен результат для запроса №1 и т. д. Это **нормально**.

##### 6) Удаление файла из индекса

```txt
remove_file PATH
```

Удаляет документ по пути `PATH` из индекса. Сам файл на диске **не трогать**. Если документа нет — проигнорировать ошибку.

##### 7) Удаление каталога из индекса

```txt
remove_dir PATH
```

Удаляет из индекса **все документы верхнего уровня** каталога `PATH` (без рекурсии).
Удаление распределяется по пулу потоков. Документы, отсутствующие в индексе, **игнорируются**.

##### 8) Рекурсивное удаление из индекса

```txt
remove_dir_recursive PATH
```

Как `remove_dir`, но рекурсивно по подкаталогам.

---

#### Что считается «словом» и как парсить текст

- Документы — обычные текстовые файлы из одной или нескольких строк.
- **Слово** — последовательность из одного или более символов **английского алфавита** `[A-Za-z]+`.
- Разделители: всё, что не входит в `[A-Za-z]`, в том числе цифры, знаки препинания, пробелы и т. п.
- Регистронезависимая нормализация: приводим слова к нижнему регистру.

> Дополнительно (по желанию): поддержка Unicode/кириллицы, стоп-слова — как бонусные фичи (см. ниже).

---

#### Структура данных

Рекомендуется использовать **инвертированный индекс**, структуру данных,
которая сопоставляет слова (термины) со списком документов, в которых эти слова встречаются:

- `term -> list of (doc_id, term_frequency_in_doc, ...)`
- Дополнительно можно хранить длину документа (кол-во слов) и общее число документов.

Допускаются иные структуры, обеспечивающие эквивалентную функциональность и асимптотику.

---

#### Параллелизм и синхронизация

- Индексация нескольких файлов — **параллельна** через пул потоков.
- Поиск может выполняться **параллельно с индексированием**.
- Используйте корректные примитивы синхронизации (мьютексы/RW-мьютексы/спинлоки/атомики),
- чтобы избежать гонок и обеспечивать **видимость данных** между потоками.
- Допускается **копия слепка** (snapshot) индекса для запроса, если это упрощает и ускоряет синхронизацию.

---

#### Модель запроса и ранжирование

##### Логика соответствия

- По умолчанию используем **конъюнкцию**: документ релевантен, если содержит хотя бы одно слово из запроса.
- Сопоставление выполняется без учёта регистра символов.

##### TF-IDF (базовая формула)

Используйте **TF-IDF** для оценки релевантности:

- TF (Term Frequency, частота термина) равен частоте термина в каждом документе, где он встречается.
  - $TF(term, doc)=count(term, doc) / words\_count(doc)$, где:
    - $count(term, doc)$ — количество раз, которое $term$ встречается в документе $doc$;
    - $word\_count(doc)$ — количество слов в документе $doc$.
- IDF (Inverse Document Frequency, обратная частота документа) термина равен логарифму
отношения числа документов к количеству документов, в которых этот термин встречается.
  - $IDF(term)=log(N / df(term)$, где
    - $N$ — общее число документов,
    - $df(term)$ — число документов, содержащих $term$.
  Основание логарифма — любое фиксированное, например $e$.
- Релевантность документа запросу равна сумме произведений TF термина и документа на IDF этого термина
  - $score(doc, query) = \sum_{term\in query} TF(term, doc) * IDF(term)$
    - Документы, в которых термин отсутствует, а также термины,
    присутствующие абсолютно во всех документах (их IDF равен 0), учитываться не должны.

Допустим, есть набор документов:

|Документ|Текст|
|--------|-------|
| a.txt  | a cat is an animal|
| b.txt  | a dog is an animal too|
| c.txt  | a sparrow is a bird|

IDF (Inverse Document Frequency, обратная частота документа) термина равен логарифму
отношения числа документов к количеству документов, в которых этот термин встречается.

Рассчитаем TF-IDF для запроса «a cat».

Рассчитаем IDF для каждого из термина.

|Документ|a           |cat              |
|--------|------------|-----------------|
|a.txt   |✅         |✅              |
|b.txt   |✅         |❌              |
|c.txt   |✅         |❌              |
|**IDF** |$log(3/3)=0$|$log(3/1)=1.0986$|

Рассчитаем TF терминов запроса для каждого из документов:

|Документ|TF("a")      |TF("cat")|
|--------|-------------|---------|
|a.txt   |$1/5=0.2$    |$1/5=0.2$|
|b.txt   |$1/6=0.16667$|$0/6=0$  |
|c.txt   |$2/5=0.4$    |$0/5=0$  |

Величина TF-IDF равна произведению IDF термина на его TF в документе.
Для оценки релевантности вычисляют сумму TF-IDF по словам документа.

|Документ|TF-IDF("a")  |TF-IDF("cat")       |Релевантность      |
|--------|-------------|--------------------|-------------------|
|a.txt   |$0.2*0=0$    |$0.2*1.0986=0.01972$|$0+0.01972=0.01972$|
|b.txt   |$0.16667*0=0$|$0*1.0986=0$        |$0+0=0$            |
|c.txt   |$0.4*0=0$    |$0*1.0986=0$        |$0+0=0$            |

В итоге самым релевантным документом среди содержащих слова «a» и «cat»
будет a.txt. Так как слово "a" встречается абсолютно во всех документах,
оно не влияет на итоговую релевантность.

---

#### Производительность (ориентиры, не жёсткие требования)

- Индексация каталога из ~10 000 средних по размеру файлов должна занимать **секунды/десятки секунд**, а не минуты.
- Поиск по 1–3 словам должен выполняться ~миллисекунды на уже построенном индексе даже при тысячах файлов.
- Пул потоков — **ограниченный** (не «по потоку на файл»).

---

#### Обработка ошибок и формат сообщений

##### Успех

- Время выполнения поиска печатайте как `Search took X.XXXXs:`.
- Релевантность выводите как число с фиксированной точностью (например, `%.5f`).

##### Ошибки (стандартный поток вывода допустим)

- Файл/каталог не найден или нет доступа:

  ```txt
  error: path not found: PATH
  ```

- Пустой запрос:

  ```txt
  error: empty query
  ```

- Документ для удаления не найден:

  ```txt
  error: file not in index: PATH
  ```

- Неизвестная команда:

  ```txt
  error: unknown command
  ```

Все ошибки **не должны** приводить к падению приложения.

---

#### Ограничения и допущения

- Индекс хранится в памяти и может занимать заметный объём.
  Для оптимизации хранения строк можете использовать `string_view` и вместо слов хранить их id. 
- Кодировка — предполагается UTF-8; символы вне `[A-Za-z]` выступают разделителями.

---

#### Рекомендации

- Рекомендуется покрыть классы тестами, в том числе проверяющими работу в многопоточном режиме.
- Для облегчения написания тестов рекомендуется работать с файловой системой не напрямую, а при помощи mock-ов.
- Прогоните стресс-тест, проиндексировав большое количество (тысячи) текстовых файлов.
  Например, исходники boost. На таких объёмах данных ошибки многопоточности быстро дают о себе знать. 

#### Контрольные вопросы (для защиты)

1. Чем инвертированный индекс лучше прямого индекса для поиска?
2. В чём смысл IDF? Что будет, если его убрать?
3. Как избежать гонок при одновременном индексировании и поиске?
4. Какие «узкие места» по памяти и времени у вашего решения? Как их улучшить?
