# Лабораторная работа №3

- [Лабораторная работа №3](#лабораторная-работа-3)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание №1 — Многопоточный поиск похожих изображений (mt-img-sim) — 100 баллов](#задание-1--многопоточный-поиск-похожих-изображений-mt-img-sim--100-баллов)
      - [Интерфейс программы](#интерфейс-программы)
      - [Допущения и ограничения](#допущения-и-ограничения)
      - [Алгоритм](#алгоритм)
        - [1. Предобработка образца (главный поток)](#1-предобработка-образца-главный-поток)
        - [2. Сканирование каталога](#2-сканирование-каталога)
        - [3. Обработка файлов (рабочие потоки)](#3-обработка-файлов-рабочие-потоки)
        - [4. Сборка результатов (главный поток)](#4-сборка-результатов-главный-поток)
      - [Пример работы](#пример-работы)
      - [Бонус за построение графика зависимости времени работы от количества потоков - 10 баллов](#бонус-за-построение-графика-зависимости-времени-работы-от-количества-потоков---10-баллов)
  - [Q\&A](#qa)
    - [1. Почему нужно переводить переводить из sRGB в линейное RGB](#1-почему-нужно-переводить-переводить-из-srgb-в-линейное-rgb)
      - [Формула sRGB → линейное RGB (γ=2.2)](#формула-srgb--линейное-rgb-γ22)
    - [2. Что такое билинейная интерполяция и зачем она нужна?](#2-что-такое-билинейная-интерполяция-и-зачем-она-нужна)
      - [Формулы](#формулы)
      - [Upscale и Downscale](#upscale-и-downscale)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее X баллов.
- На оценку хорошо нужно набрать не менее Y баллов.
- Для получения оценки "отлично" нужно набрать не менее Z баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание №1 — Многопоточный поиск похожих изображений (mt-img-sim) — 100 баллов

Реализовать утилиту, которая ищет в каталоге изображения, **наиболее похожие** на заданное изображение-образец.
Сравнение проводится по метрике **MSE** после нормализации всех изображений к фиксированному размеру и цветовому пространству.
Каждый поток обрабатывает свой поднабор файлов, поэтому
многопоточность может дать ускорение вплоть до линейного при росте числа потоков.

MSE (Mean Squared Error, среднеквадратическое отклонение) — это простая и широко используемая метрика
для измерения различия между двумя наборами данных одинакового размера.
В задачах обработки изображений MSE обычно применяется для оценки степени отличия одного изображения от другого
(например, оригинала и обработанного, или «образца» и кандидата на схожесть).

Вычисление метрики MSE для RGB-изображения размером Width * Height:

$$
    \text{MSE} = \frac{1}{3 \cdot Width \cdot Height}\sum (Q_{i} - C_{i})^2
$$

  где $Q_i$ — значение пикселя образца, $C_i$ — кандидата.

---

#### Интерфейс программы

```bash
mt-img-sim QUERY_IMAGE INPUT_DIR -j NUM_THREADS --top K --threshold T
```

- `QUERY_IMAGE` — путь к файлу-образцу.
- `INPUT_DIR` — каталог с изображениями-кандидатами (просматривается **рекурсивно**).
- `-j NUM_THREADS` — количество потоков (≥1).
- `--top K` — вывести K наиболее похожих изображений.
- `--threshold T` — вывести все изображения, у которых MSE ≤ T.

Вывод всегда plain-text в stdout.

---

#### Допущения и ограничения

- Достаточно поддержать только **PNG** и **JPEG** (основные форматы).
- Все изображения конвертируются в **RGB**, 8 бит на канал.
- Перед сравнением применяется:
  - перевод из sRGB в линейное пространство и обратно с фиксированным γ = 2.2 (см. ниже),
  - масштабирование до **256×256** пикселей с использованием **билинейной интерполяции**.
- Цветовое пространство фиксировано: **RGB**.
- Код возврата:
  - `0` — успех,
  - `1` — ошибка аргументов,
  - `2` — ошибка чтения файла.

---

#### Алгоритм

##### 1. Предобработка образца (главный поток)

- Загрузить изображение.
- Преобразовать в RGB.
- Применить γ=2.2 (sRGB → linear).
- Downscale/Upscale до 256×256 (билинейно).
- Получить массив пикселей для сравнения.

##### 2. Сканирование каталога

- Рекурсивно собрать список всех PNG/JPEG в `INPUT_DIR`.
- Отсортировать список.
- Разбить список на блоки: каждому из `NUM_THREADS` потоков выдать свою последовательность файлов.

##### 3. Обработка файлов (рабочие потоки)

Для каждого файла:

- Загрузить, преобразовать в RGB, применить γ=2.2, downscale 256×256.
- Посчитать MSE:

##### 4. Сборка результатов (главный поток)

- Объединить локальные списки.
- Отсортировать по MSE (возрастание).
- Отобрать:
  - первые `K` файлов, и/или
  - все файлы с `mse ≤ T`.
- Вывести в stdout:

  ```txt
  <mse>  <path>
  ```

---

#### Пример работы

```bash
mt-img-sim query.png ./dataset -j 4 --top 5 --threshold 2000
```

Ожидаемый вывод:

```txt
1350.2  dataset/cat/cat1.jpg
1422.7  dataset/cat/cat2.png
1670.3  dataset/cat/cat5.jpg
1901.6  dataset/dog/dog1.jpg
```

#### Бонус за построение графика зависимости времени работы от количества потоков - 10 баллов

Измерьте время работы программы на достаточно большом наборе изображений в зависимости от количества потоков.
Количество изображений должно быть больше количества потоков не менее чем в 2-3 раза,
и таким, чтобы при одном потоке время работы было не менее 15-20 секунд.

## Q&A

### 1. Почему нужно переводить переводить из sRGB в линейное RGB

Файлы PNG и JPEG обычно хранят цвета в пространстве **sRGB**.
Оно использует **гамма-коррекцию**: значения в файле — это не «настоящие» линейные интенсивности света,
а уже нелинейно преобразованные для того, чтобы лучше соответствовать
чувствительности человеческого глаза и возможностям мониторов.

- Если взять эти sRGB-значения и напрямую усреднять (например, при билинейной интерполяции),
  то результат будет **нефизически корректным**: цвета будут смещаться и затемняться/осветляться не так, как ожидалось.
- Поэтому перед любым **интерполяционным вычислением** (upscale/downscale) принято переводить значения
  из sRGB в **линейное RGB**, там делать арифметику, и затем возвращать обратно в sRGB для хранения.

#### Формула sRGB → линейное RGB (γ=2.2)

Для каждого канала $c_{srgb}$ в диапазоне \[0, 1]:

$$
c_{lin} =
\begin{cases}
\dfrac{c_{srgb}}{12.92}, & c_{srgb} \leq 0.04045 \\
\left(\dfrac{c_{srgb} + 0.055}{1.055}\right)^{2.4}, & c_{srgb} > 0.04045
\end{cases}
$$

Обратно (линейное → sRGB):

$$
c_{srgb} =
\begin{cases}
12.92 \cdot c_{lin}, & c_{lin} \leq 0.0031308 \\
1.055 \cdot c_{lin}^{1/2.4} - 0.055, & c_{lin} > 0.0031308
\end{cases}
$$

> В учебных программах можно упростить: использовать фиксированную гамму $γ=2.2$, т.е.
> `c_lin = pow(c_srgb, 2.2)` и обратно `c_srgb = pow(c_lin, 1/2.2)`. Это чуть менее точно, но проще.

### 2. Что такое билинейная интерполяция и зачем она нужна?

**Идея:** значение пикселя в новой сетке берётся как **взвешенное среднее четырёх ближайших пикселей** в исходном изображении.

#### Формулы

Пусть у нас есть целевая координата $(x, y)$ в новом изображении.
Её координата в исходном (после масштабирования) — $(u, v)$, где $u, v$ могут быть дробными:

$$
u = x \cdot \frac{W_{src}}{W_{dst}}, \quad v = y \cdot \frac{H_{src}}{H_{dst}}
$$

- Пусть $u_0 = \lfloor u \rfloor, \; u_1 = u_0 + 1$
- Пусть $v_0 = \lfloor v \rfloor, \; v_1 = v_0 + 1$
- Пусть $\alpha = u - u_0, \; \beta = v - v_0$ — дробные части.

Тогда значение цвета в $(x,y)$:

$$
C(x,y) = (1-\alpha)(1-\beta)\,C(u_0,v_0) + \alpha(1-\beta)\,C(u_1,v_0) + (1-\alpha)\beta\,C(u_0,v_1) + \alpha\beta\,C(u_1,v_1)
$$

То есть линейная интерполяция сначала по X, потом по Y.

#### Upscale и Downscale

- **Upscale (увеличение)** — новая сетка плотнее, координаты $(u,v)$ «гуляют» между исходными пикселями.
  Билинейная интерполяция сглаживает результат.
- **Downscale (уменьшение)** — новая сетка реже, и каждый новый пиксель усредняет несколько исходных.
  Билинейная интерполяция даёт плавный результат, но может быть «замыливание».
  Для очень сильного уменьшения лучше бы усреднять блоки (box filter), но для учебных целей билинейный метод достаточно нагляден.

Например, исходное 2×2 изображение (яркости) после преобразования из sRGB в RGB:

```txt
100 200
150 250
```

Хотим downscale до 1×1 (всё изображение в одну точку).
Тогда формула даёт:

$$
(100 \cdot 0.25) + (200 \cdot 0.25) + (150 \cdot 0.25) + (250 \cdot 0.25) = 175
$$

А это и есть среднее значение — корректно.
