# Лабораторная работа №3

- [Лабораторная работа №3](#лабораторная-работа-3)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание №1 — Многопоточный поиск похожих изображений (mt-img-sim) — 100 баллов](#задание-1--многопоточный-поиск-похожих-изображений-mt-img-sim--100-баллов)
      - [Интерфейс программы](#интерфейс-программы)
      - [Допущения и ограничения](#допущения-и-ограничения)
      - [Алгоритм](#алгоритм)
        - [1. Предобработка образца (главный поток)](#1-предобработка-образца-главный-поток)
        - [2. Сканирование каталога](#2-сканирование-каталога)
        - [3. Обработка файлов (рабочие потоки)](#3-обработка-файлов-рабочие-потоки)
        - [4. Сборка результатов (главный поток)](#4-сборка-результатов-главный-поток)
      - [Пример работы](#пример-работы)
      - [Бонус за построение графика зависимости времени работы от количества потоков - 10 баллов](#бонус-за-построение-графика-зависимости-времени-работы-от-количества-потоков---10-баллов)
      - [Бонус за более эффективное распределение файлов между потоками за счёт пула потоков — +20 баллов](#бонус-за-более-эффективное-распределение-файлов-между-потоками-за-счёт-пула-потоков--20-баллов)
    - [Задание №2 — Пакетная генерация миниатюр (thumbgen) — 60 баллов](#задание-2--пакетная-генерация-миниатюр-thumbgen--60-баллов)
      - [Интерфейс](#интерфейс)
      - [Алгоритм](#алгоритм-1)
      - [Пример запуска](#пример-запуска)
      - [Требования к реализации](#требования-к-реализации)
      - [Бонус за построение графика зависимости времени работы от количества потоков - 10 баллов](#бонус-за-построение-графика-зависимости-времени-работы-от-количества-потоков---10-баллов-1)
      - [Бонус за более эффективное распределение файлов между потоками за счёт пула потоков — +20 баллов](#бонус-за-более-эффективное-распределение-файлов-между-потоками-за-счёт-пула-потоков--20-баллов-1)
  - [Q\&A](#qa)
    - [1. Почему нужно переводить переводить из sRGB в линейное RGB](#1-почему-нужно-переводить-переводить-из-srgb-в-линейное-rgb)
      - [Формула sRGB → линейное RGB (γ=2.2)](#формула-srgb--линейное-rgb-γ22)
    - [2. Что такое билинейная интерполяция и зачем она нужна?](#2-что-такое-билинейная-интерполяция-и-зачем-она-нужна)
      - [Формулы](#формулы)
      - [Upscale и Downscale](#upscale-и-downscale)
    - [3. Зачем и как ограничить количество параллельно запущенных задач при использовании `std::async`?](#3-зачем-и-как-ограничить-количество-параллельно-запущенных-задач-при-использовании-stdasync)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 80 баллов.
- На оценку хорошо нужно набрать не менее 120 баллов.
- Для получения оценки "отлично" нужно набрать не менее 200 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание №1 — Многопоточный поиск похожих изображений (mt-img-sim) — 100 баллов

Реализовать утилиту, которая ищет в каталоге изображения, **наиболее похожие** на заданное изображение-образец.
Сравнение проводится по метрике **MSE** после нормализации всех изображений к фиксированному размеру и цветовому пространству.
Каждый поток обрабатывает свой поднабор файлов, поэтому
многопоточность может дать ускорение вплоть до линейного при росте числа потоков.

MSE (Mean Squared Error, среднеквадратическое отклонение) — это простая и широко используемая метрика
для измерения различия между двумя наборами данных одинакового размера.
В задачах обработки изображений MSE обычно применяется для оценки степени отличия одного изображения от другого
(например, оригинала и обработанного, или «образца» и кандидата на схожесть).

Вычисление метрики MSE для RGB-изображения размером Width * Height:

$$
    \text{MSE} = \frac{1}{3 \cdot Width \cdot Height}\sum (Q_{i} - C_{i})^2
$$

  где $Q_i$ — значение пикселя образца, $C_i$ — кандидата.

---

#### Интерфейс программы

```bash
mt-img-sim QUERY_IMAGE INPUT_DIR -j NUM_THREADS --top K --threshold T
```

- `QUERY_IMAGE` — путь к файлу-образцу.
- `INPUT_DIR` — каталог с изображениями-кандидатами (просматривается **рекурсивно**).
- `-j NUM_THREADS` — количество потоков (≥1).
- `--top K` — вывести K наиболее похожих изображений.
- `--threshold T` — вывести все изображения, у которых MSE ≤ T.

Вывод всегда plain-text в stdout.

---

#### Допущения и ограничения

- Достаточно поддержать только **PNG** и **JPEG** (основные форматы).
- Все изображения конвертируются в **RGB**, 8 бит на канал.
- Перед сравнением применяется:
  - перевод из sRGB в линейное пространство и обратно с фиксированным γ = 2.2 (см. ниже),
  - масштабирование до **256×256** пикселей с использованием **билинейной интерполяции**.
- Цветовое пространство фиксировано: **RGB**.
- Код возврата:
  - `0` — успех,
  - `1` — ошибка аргументов,
  - `2` — ошибка чтения файла.

---

#### Алгоритм

##### 1. Предобработка образца (главный поток)

- Загрузить изображение.
- Преобразовать в RGB.
- Применить γ=2.2 (sRGB → linear).
- Downscale/Upscale до 256×256 (билинейно).
- Получить массив пикселей для сравнения.

##### 2. Сканирование каталога

- Рекурсивно собрать список всех PNG/JPEG в `INPUT_DIR`.
- Отсортировать список.
- Разбить список на блоки: каждому из `NUM_THREADS` потоков выдать свою последовательность файлов.

##### 3. Обработка файлов (рабочие потоки)

Для каждого файла:

- Загрузить, преобразовать в RGB, применить γ=2.2, downscale 256×256.
- Посчитать MSE:

##### 4. Сборка результатов (главный поток)

- Объединить локальные списки.
- Отсортировать по MSE (возрастание).
- Отобрать:
  - первые `K` файлов, и/или
  - все файлы с `mse ≤ T`.
- Вывести в stdout:

  ```txt
  <mse>  <path>
  ```

---

#### Пример работы

```bash
mt-img-sim query.png ./dataset -j 4 --top 5 --threshold 2000
```

Ожидаемый вывод:

```txt
1350.2  dataset/cat/cat1.jpg
1422.7  dataset/cat/cat2.png
1670.3  dataset/cat/cat5.jpg
1901.6  dataset/dog/dog1.jpg
```

#### Бонус за построение графика зависимости времени работы от количества потоков - 10 баллов

Измерьте время работы программы на достаточно большом наборе изображений в зависимости от количества потоков.
Количество изображений должно быть больше количества потоков не менее чем в 2-3 раза,
и таким, чтобы при одном потоке время работы было не менее 15-20 секунд.

#### Бонус за более эффективное распределение файлов между потоками за счёт пула потоков — +20 баллов

Если разделить набор файлов между потоками фиксированным образом, может оказаться так,
что некоторыми из них достанется сильно меньше работы, что снизит использование процессора
и увеличит время работы программы. Улучшить утилизацию CPU можно за счёт использования пула потоков.

Пул потоков позволяет иметь ограниченное количество рабочих потоков, которым динамически раздаются задачи.
Когда один поток завершает обработку файла, он сразу может взять следующий из очереди,
не дожидаясь других. Это особенно полезно, когда время обработки разных файлов сильно различается.

Для учебных целей можно использовать готовые средства:

- `boost::asio::thread_pool` — предоставляет пул потоков и удобный интерфейс для постановки задач;
- `std::async(std::launch::async)` — стандартный механизм асинхронного запуска функций,
  которым тоже можно ограничить параллелизм, например, через семафор или «скользящее окно» задач.

Оба подхода помогают равномерно загружать процессор и получать более предсказуемое ускорение при увеличении числа потоков.

### Задание №2 — Пакетная генерация миниатюр (thumbgen) — 60 баллов

Разработайте кроссплатформенную утилиту **thumbgen**, которая для всех изображений в каталоге (рекурсивно)
создаёт уменьшенные копии (thumbnails) фиксированного размера.
Задача показывает, как использовать пул потоков или асинхронный запуск задач для параллельной обработки множества файлов.

#### Интерфейс

```bash
thumbgen INPUT_DIR OUTPUT_DIR --size=WxH -j NUM_THREADS
```

- `INPUT_DIR` — путь к каталогу с изображениями.
- `OUTPUT_DIR` — путь к каталогу для результатов (создаётся при необходимости).
- `--size=WxH` — размер создаваемых миниатюр, например `256x256`.
- `-j NUM_THREADS` — число рабочих потоков (≥1).

**Жёстко заданные правила:**

- Всегда обрабатывать **рекурсивно** все подпапки.
- Миниатюры всегда сохраняются в формате **PNG**.
- К имени файла всегда добавляется суффикс **`_thumb`** перед расширением.
- При совпадении имён — миниатюры всегда **перезаписываются**.

Примеры:

- `cat.jpg` → `cat_thumb.png`
- `dir1/dog.png` → `OUTPUT_DIR/dir1/dog_thumb.png`

---

#### Алгоритм

1. **Сканирование входного каталога**
   - Рекурсивно найти все `.jpg`, `.jpeg`, `.png`.
   - Отсортировать список для детерминизма.
2. **Организация многопоточности**
   - На каждый входной файл поставить задачу: «прочитать → уменьшить → сохранить».
3. **Обработка одного файла**
   - Прочитать изображение и преобразовать в RGB.
   - Выполнить уменьшение до `WxH` с помощью **билинейной интерполяции** (алгоритм описан ниже).
   - Преобразовать обратно в sRGB.
   - Сохранить в `OUTPUT_DIR` с добавлением `_thumb.png`.
   - В случае ошибки — вывести предупреждение, но продолжить работу.
4. **Завершение**
   - Дождаться выполнения всех задач.
   - Напечатать в stdout краткую статистику:

     ```txt
     processed=N_ok failed=N_err
     ```

---

#### Пример запуска

```bash
thumbgen ./photos ./thumbs --size=128x128 -j 4
```

Результат:

- В `./thumbs` появится зеркальная структура папок с файлами `_thumb.png`.
- На экране:

  ```txt
  processed=245 failed=3
  ```

---

#### Требования к реализации

- Использовать RAII-обёртки для работы с ресурсами.
- Проверять ошибки чтения/записи.
- Использовать **билинейную интерполяцию** при уменьшении, выполняемую в линейном RGB-пространстве.

#### Бонус за построение графика зависимости времени работы от количества потоков - 10 баллов

Измерьте время работы программы на достаточно большом наборе изображений в зависимости от количества потоков.
Количество изображений должно быть больше количества потоков не менее чем в 2-3 раза,
и таким, чтобы при одном потоке время работы было не менее 15-20 секунд.

#### Бонус за более эффективное распределение файлов между потоками за счёт пула потоков — +20 баллов

Если разделить набор файлов между потоками фиксированным образом, может оказаться так,
что некоторыми из них достанется сильно меньше работы, что снизит использование процессора
и увеличит время работы программы. Улучшить утилизацию CPU можно за счёт использования пула потоков.

Пул потоков позволяет иметь ограниченное количество рабочих потоков, которым динамически раздаются задачи.
Когда один поток завершает обработку файла, он сразу может взять следующий из очереди,
не дожидаясь других. Это особенно полезно, когда время обработки разных файлов сильно различается.

Для учебных целей можно использовать готовые средства:

- `boost::asio::thread_pool` — предоставляет пул потоков и удобный интерфейс для постановки задач;
- `std::async(std::launch::async)` — стандартный механизм асинхронного запуска функций,
  которым тоже можно ограничить параллелизм, например, через семафор или «скользящее окно» задач.

Оба подхода помогают равномерно загружать процессор и получать более предсказуемое ускорение при увеличении числа потоков.


## Q&A

### 1. Почему нужно переводить переводить из sRGB в линейное RGB

Файлы PNG и JPEG обычно хранят цвета в пространстве **sRGB**.
Оно использует **гамма-коррекцию**: значения в файле — это не «настоящие» линейные интенсивности света,
а уже нелинейно преобразованные для того, чтобы лучше соответствовать
чувствительности человеческого глаза и возможностям мониторов.

- Если взять эти sRGB-значения и напрямую усреднять (например, при билинейной интерполяции),
  то результат будет **нефизически корректным**: цвета будут смещаться и затемняться/осветляться не так, как ожидалось.
- Поэтому перед любым **интерполяционным вычислением** (upscale/downscale) принято переводить значения
  из sRGB в **линейное RGB**, там делать арифметику, и затем возвращать обратно в sRGB для хранения.

#### Формула sRGB → линейное RGB (γ=2.2)

Для каждого канала $c_{srgb}$ в диапазоне \[0, 1]:

$$
c_{lin} =
\begin{cases}
\dfrac{c_{srgb}}{12.92}, & c_{srgb} \leq 0.04045 \\
\left(\dfrac{c_{srgb} + 0.055}{1.055}\right)^{2.4}, & c_{srgb} > 0.04045
\end{cases}
$$

Обратно (линейное → sRGB):

$$
c_{srgb} =
\begin{cases}
12.92 \cdot c_{lin}, & c_{lin} \leq 0.0031308 \\
1.055 \cdot c_{lin}^{1/2.4} - 0.055, & c_{lin} > 0.0031308
\end{cases}
$$

> В учебных программах можно упростить: использовать фиксированную гамму $γ=2.2$, т.е.
> `c_lin = pow(c_srgb, 2.2)` и обратно `c_srgb = pow(c_lin, 1/2.2)`. Это чуть менее точно, но проще.

### 2. Что такое билинейная интерполяция и зачем она нужна?

**Идея:** значение пикселя в новой сетке берётся как **взвешенное среднее четырёх ближайших пикселей** в исходном изображении.

#### Формулы

Пусть у нас есть целевая координата $(x, y)$ в новом изображении.
Её координата в исходном (после масштабирования) — $(u, v)$, где $u, v$ могут быть дробными:

$$
u = x \cdot \frac{W_{src}}{W_{dst}}, \quad v = y \cdot \frac{H_{src}}{H_{dst}}
$$

- Пусть $u_0 = \lfloor u \rfloor, \; u_1 = u_0 + 1$
- Пусть $v_0 = \lfloor v \rfloor, \; v_1 = v_0 + 1$
- Пусть $\alpha = u - u_0, \; \beta = v - v_0$ — дробные части.

Тогда значение цвета в $(x,y)$:

$$
C(x,y) = (1-\alpha)(1-\beta)\,C(u_0,v_0) + \alpha(1-\beta)\,C(u_1,v_0) + (1-\alpha)\beta\,C(u_0,v_1) + \alpha\beta\,C(u_1,v_1)
$$

То есть линейная интерполяция сначала по X, потом по Y.

#### Upscale и Downscale

- **Upscale (увеличение)** — новая сетка плотнее, координаты $(u,v)$ «гуляют» между исходными пикселями.
  Билинейная интерполяция сглаживает результат.
- **Downscale (уменьшение)** — новая сетка реже, и каждый новый пиксель усредняет несколько исходных.
  Билинейная интерполяция даёт плавный результат, но может быть «замыливание».
  Для очень сильного уменьшения лучше бы усреднять блоки (box filter), но для учебных целей билинейный метод достаточно нагляден.

Например, исходное 2×2 изображение (яркости) после преобразования из sRGB в RGB:

```txt
100 200
150 250
```

Хотим downscale до 1×1 (всё изображение в одну точку).
Тогда формула даёт:

$$
(100 \cdot 0.25) + (200 \cdot 0.25) + (150 \cdot 0.25) + (250 \cdot 0.25) = 175
$$

А это и есть среднее значение — корректно.

### 3. Зачем и как ограничить количество параллельно запущенных задач при использовании `std::async`?

В многопоточных программах часто хочется запускать множество задач параллельно,
но при этом не перегружать систему слишком большим количеством одновременно работающих потоков.
Например, если файлов для обработки сотни, а доступных ядер всего четыре,
запускать сотню `std::async` сразу будет неэффективно:
система начнёт тратить время на лишнее переключение контекста и очереди задач.
Даже если `std::async` будет выполнять работу на некотором системном пуле потоков,
может возникнуть желание ограничить максимальное количество параллельно выполняемых задач меньшим значением,
чем количество ядер процессора.

Для ограничения количества одновременно выполняемых задач удобно использовать семафор.
В приведённом ниже коде каждая задача перед запуском «захватывает слот» семафора,
а после завершения — автоматически освобождает его. Таким образом,
в любой момент времени работает не более maxConcurrency задач.

Класс `Slot` реализует RAII-обёртку: в конструкторе вызывает `acquire()`, в деструкторе — `release()`.
Он некопируемый, но перемещаемый, чтобы владение можно было безопасно передавать в лямбду `std::async`.
В деструкторе возможные исключения из release() подавляются,
чтобы не допустить аварийного завершения при разрушении объектов.

Функция `RunLimitedAsync` принимает список файлов и количество слотов (`maxConcurrency`),
создаёт семафор и запускает задачи через `std::async`, гарантируя,
что в системе одновременно будет выполняться не больше заданного числа задач.

```cpp
#include <semaphore>
#include <future>
#include <vector>
#include <string>
#include <algorithm>
#include <climits>   // INT_MAX

void ProcessFile(const std::string& path); // ваша реализация

// RAII-"слот": acquire в конструкторе, release в деструкторе.
class Slot
{
    explicit Slot(std::counting_semaphore<INT_MAX>& s)
        : m_sem(&s), m_owns(true)
    {
        m_sem->acquire();
    }

    // Копирование запрещено
    Slot(const Slot&) = delete;
    Slot& operator=(const Slot&) = delete;

    // Перемещение разрешено
    Slot(Slot&& other) noexcept
        : m_sem(other.m_sem), m_owns(other.m_owns)
    {
        other.m_sem = nullptr;
        other.m_owns = false;
    }

    // Перемещающее присваивание: может вызвать Release(), поэтому НЕ noexcept
    Slot& operator=(Slot&& other) noexcept(false)
    {
        if (this != &other)
        {
            Release();              // может бросить
            m_sem  = std::exchange(other.m_sem, nullptr);
            m_owns = std::exchange(other.m_owns, false);
        }
        return *this;
    }

    // Явный release: потенциально бросающий
    void Release()
    {
        if (m_owns && m_sem)
        {
            m_sem->release();       // предположительно может бросить std::system_error
            m_owns = false;
        }
    }

    // Деструктор не должен бросать: перехватываем любую ошибку Release()
    ~Slot() noexcept
    {
        if (m_owns && m_sem)
        {
            try
            {
                m_sem->release();
            }
            catch (...)
            {
                // Логирование по желанию; исключения из деструктора подавляются
            }
            m_owns = false;
        }
    }

private:
    std::counting_semaphore<INT_MAX>* m_sem = nullptr;
    bool m_owns = false;
};

void RunLimitedAsync(std::vector<std::string> files, int maxConcurrency)
{
    if (maxConcurrency < 1) maxConcurrency = 1;
    std::sort(files.begin(), files.end()); // детерминизм (опционально)

    std::counting_semaphore<INT_MAX> sem(maxConcurrency);
    std::vector<std::future<void>> futures;
    futures.reserve(files.size());

    for (const auto& f : files)
    {
        Slot slot(sem); // захватываем слот ДО запуска задачи
        futures.push_back(std::async(std::launch::async,
            [slot = std::move(slot), f]() mutable
            {
                ProcessFile(f);
                // По выходу из лямбды деструктор Slot вызовет release() и подавит исключения, если они возникнут
            }));
    }

    // Дожидаемся всех задач и пробрасываем исключения из ProcessFile
    for (auto& fu : futures)
    {
        fu.get();
    }
}
```
