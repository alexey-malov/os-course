# Лабораторная работа №6

- [Лабораторная работа №6](#лабораторная-работа-6)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — B+ дерево — 100 баллов](#задание-1--b-дерево--100-баллов)
      - [Цели](#цели)
      - [Задача](#задача)
      - [Идеи](#идеи)
    - [Задание 2 — Растровый редактор для гигапиксельных изображений — 200 баллов](#задание-2--растровый-редактор-для-гигапиксельных-изображений--200-баллов)
      - [Цель работы](#цель-работы)
      - [Задача](#задача-1)
      - [Функциональные требования](#функциональные-требования)
      - [Бонус за поддержку Zoom-In/Zoom-Out — 30 баллов](#бонус-за-поддержку-zoom-inzoom-out--30-баллов)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 80 баллов.
- Для получения оценки "хорошо" нужно набрать не менее 180 баллов.
- Для получения оценки "отлично" нужно набрать не менее 260 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — B+ дерево — 100 баллов

#### Цели

- Научиться использовать memory-mapped files (mmap/MapViewOfFile) как альтернативу обычному I/O.
- Реализовать B+ дерево, поддерживающее операции: поиск, вставка, удаление.
- Освоить дизайн дискового формата: фиксированные страницы, смещения вместо указателей, метаданные.
- Отработать вопросы согласованности данных, расширения файла и принудительной записи (msync/FlushViewOfFile).
- Для работы с memory-mapped файлами вы можете использовать как функции ОС,
  так и кроссплатформенную библиотеку [Boost.Interprocess](https://www.boost.org/doc/libs/latest/doc/html/interprocess/sharedmemorybetweenprocesses.html).

#### Задача

Разработать утилиту, которая хранит B+ дерево в одном файле и работает с ним через memory mapping,
как если бы это была обычная структура в ОЗУ.

Операции:

- `GET key` → выводит значение, соответствующее ключу `key` или "NOT FOUND"
- `PUT key value` → вставляет или заменяет значение по ключу
- `DEL key` → удаляет ключ, если есть
- `STATS` → печатает параметры дерева (высота, число узлов, заполненность и т.п.)
- `LIST num [start]` выводит `num` ключей пропуская `start` ключей (по умолчанию=0).

Поддерживаемые типы:

- `key`: беззнаковый 64-бит (uint64_t).
- `value`: ASCII-строка переменной длины, длина которой не превышает 119 символов.

Путь к дереву передаётся программе через командную строку. При выходе все данные должны быть записаны на диск.

#### Идеи

Самую первую страницу файла сделайте информационной. Примерная структура такая

```txt
[0x00] magic        = "BPL1"        (4B)
[0x04] version      = 1             (u32)
[0x08] page_size    = 4096          (u32)
[0x0C] flags/reserved
[0x10] root_page    (u64)           // = NULL_PAGE, если пусто
[0x18] height       (u32)           // высота (кол-во уровней)
[0x1C] order_leaf   (u16)           // max записей в листе (M_leaf)
[0x1E] order_int    (u16)           // max ключей во внутреннем (M_int)
[0x20] free_head    (u64)           // голова списка свободных страниц (номер страницы)
[0x28] next_pid     (u64)           // следующий page_id при расширении файла
[0x30] keys_count   (u64)           // кол-во ключей в дереве
[0x38] nodes_count  (u64)           // кол-во узлов (страниц) дерева
   ... до 4096 байт нулями
```

Общий заголовок страницы узла

```txt
[0x00] node_type  (u8)   // 0 = internal, 1 = leaf, 0xFF = free
[0x01] reserved   (u8)   // для выравнивания
[0x02] num_keys   (u16)  // фактическое число ключей в узле
[0x04] reserved   (u32)  // для выравнивания
[0x08] parent     (u64)  // можно = NULL_PAGE для корня (опционально)
[0x10] next_leaf  (u64)  // только для листа, иначе 0
[0x18] prev_leaf  (u64)  // только для листа, иначе 0
[0x20] reserved... (до 0x40)
[0x40] payload    // см. ниже
```

Внутренний узел

- В B+ дереве внутренние узлы хранят только ключи и указатели на детей
  
```txt
P0, K0, P1, K1, ... , K(m-1), Pm
где m = num_keys,  K[i]=u64,  P[i]=u64 (page_id)
```

Payload одной страницы составит $4096-64=4032$ байта. Для $m$ ключей требуется $m*8 + (m+1)*8=16m+8$ байт,
то есть в одной странице можно сохранить порядка $M_{int}=250$ ключей.

Минимальная заполненность узла: $ceil(M_{int}/2)=125$ ключей.

Листья

- В листе храним пары (key, value) строго по возрастанию ключей
- Каждая запись: 8 (key) + 120 (value)=128 байт. Строка длиной до 119 символов занимает в памяти 120 байт
  (1 байт нужен на хранение длины)
- Вместимость payload: `4032/128=31`. Итого $M_{leaf}=31$ (макс. записей в листе)
- Минимум для листа: $ceil(31/2)=16$ записей
- В листах поддерживаем двухсвязную цепочку через `next_leaf/prev_leaf` для быстрых сканов диапазонов

Менеджер страниц

- free-list: односвязный список страниц типа `node_type=0xff`.
  Для свободных страниц вместо заголовка можно поместить id следующей свободной страницы.
- Аллокация: взять free_head; если пусто — увеличить файл (пакетно, например на 1024 страниц),
  связав их в free list.
- Освобождение: положить в голову free list.
- При модификациях вызывать msync/FlushViewOfFile

Рекомендуется написать для приложения ряд юнит- и стресс-тестов,
чтобы обнаружить как можно больше ошибок.

### Задание 2 — Растровый редактор для гигапиксельных изображений — 200 баллов

#### Цель работы

Освоить механизмы управления виртуальной памятью на прикладном уровне:

- отобразить (map) файл в адресное пространство процесса,
- реализовать доступ к данным напрямую через память без системных вызовов read() и write(),
- понять связь между страничной организацией ОС и структурой данных приложения,
- применить эти принципы для создания простого растрового редактора,
  работающего с огромным изображением (порядка миллиардов пикселей).
- Для работы с memory-mapped файлами вы можете использовать как функции ОС,
  так и кроссплатформенную библиотеку [Boost.Interprocess](https://www.boost.org/doc/libs/latest/doc/html/interprocess/sharedmemorybetweenprocesses.html).

#### Задача

Разработать оконное приложение, которое:

- Хранит огромное RGB32-изображение (до нескольких гигапикселей) в файле,
  разбитом на тайлы размером 32×32 пикселя × 4 байта = 4096 байт.
  Можно использовать и тайлы бОльшего размера (64×64 или 128×128).
- Использует отображение файла в память (memory mapping) для доступа к тайлам,
  которые находятся в видимой области изображения.
- В оперативной памяти одновременно находится только небольшая часть изображения
  (видимая область и небольшой кэш вокруг неё).
- Реализует возможность панорамирования (scroll/pan) и масштабирования (zoom).
- При уменьшении масштаба используется предварительно рассчитанная многоуровневая пирамида (mip levels).
- При увеличении — загружаются тайлы базового уровня.
- При работе с жёстким диском (HDD) обеспечивает эффективный доступ к данным,
  размещая тайлы в файле в порядке Z-кривой (Morton order) для пространственной локальности.
- Позволяет редактировать пиксели (простейшие операции: рисование линий).
- Обеспечивает сохранение изменений на диск (через msync() или FlushViewOfFile()).

#### Функциональные требования

- Создание файла изображения
  - Пользователь задаёт исходное разрешение (W×H) и число уровней mip-пирамиды.
  - Программа создаёт файл, инициализирует заголовок и резервирует место под все тайлы (через ftruncate() / resize_file()).
- Отображение в память
  - Использовать Boost.Interprocess (boost::interprocess::file_mapping и boost::interprocess::mapped_region)
или Boost.Iostreams (mapped_file).
  - Каждая страница файла должна соответствовать одному тайлу.
  - Реализовать класс TileCache, который хранит ограниченное число отмапленных тайлов (LRU-кэш).
- Отрисовка и визуализация
  - Реализовать вывод текущего окна просмотра в консоль или окно (например, через SDL2 или SFML).
  - Добавить панорамирование (стрелки клавиатуры / мышь) и масштабирование (Zoom In / Out).
  - При Zoom Out выбирать соответствующий уровень mip-пирамиды.
- Редактирование
  - Реализовать простую операцию «кисть» (покрасить пиксели выбранным цветом).
  - При изменении тайла отмечать его как «грязный» (dirty) и сбрасывать при выходе (region.flush()).
- Mip-уровни (Level of Detail)
  - Реализовать генерацию mip-уровней при создании файла (даунскейл в 2× по каждому измерению).
  - Построение mip-уровней рекомендуется делать в фоновом потоке
- Z-кривая (Morton order)
  - Тайлы лучше хранить в файле не построчно, а так, чтобы близко расположенные тайлы располагались близко друг к другу,
  например, в виде [Z-кривой](https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%B8%D0%B2%D0%B0%D1%8F_%D0%9C%D0%BE%D1%80%D1%82%D0%BE%D0%BD%D0%B0). 

#### Бонус за поддержку Zoom-In/Zoom-Out — 30 баллов

Пользователь должен иметь возможность управлять масштабом изображения.
Чтобы уменьшить количество тайлов, отображаемых в память, при уменьшении масштаба,
используйте мип-уровни - уменьшенные в 2 раза версии изображения.

Для этого для каждого блока 2×2 тайла создайте 1 тайл, используя билинейную фильтрацию.
Процесс продолжается рекурсивно, пока количество тайлов по большей оси
не станет меньше некоторого разумного значения.

![mip-maps](images/MipMaps.svg)

Хранение дополнительных тайлов потребует не больше 33% дополнительной памяти.

При модификации изображения в процессе рисования нужно пересчитывать тайлы меньших уровней детализации.
Например, при изменении тайла A нужно перестроить тайлы A' и A''.

![mip-maps](images/UpdateMipMaps.svg)

Чтобы не перестраивать пирамиду тайлов при любом изменении тайла,
придумайте способ сделать это более оптимальным образом.
