# Лабораторная работа №1

- [Лабораторная работа №1](#лабораторная-работа-1)
  - [Задания](#задания)
    - [Требования](#требования)
    - [Задание 1 — sys-info-win — 50 баллов](#задание-1--sys-info-win--50-баллов)
      - [Пример выводимой информации](#пример-выводимой-информации)
      - [Подсказки](#подсказки)
    - [Задание 2 — sys-info-linux — 50 баллов](#задание-2--sys-info-linux--50-баллов)
      - [Пример выводимой информации](#пример-выводимой-информации-1)
    - [Задание 3 — sys-info-crossplatform — 30 баллов](#задание-3--sys-info-crossplatform--30-баллов)
      - [Подсказки](#подсказки-1)
    - [Задание 4 — Знакомство утилитами Linux часть 1 — 40 баллов](#задание-4--знакомство-утилитами-linux-часть-1--40-баллов)
    - [Задание 5 —  Знакомство утилитами Linux часть 2 — 60 баллов](#задание-5---знакомство-утилитами-linux-часть-2--60-баллов)
  - [Настройка системы](#настройка-системы)
    - [Обновление пакетного менеджера apt](#обновление-пакетного-менеджера-apt)
    - [Установка компилятора g++](#установка-компилятора-g)
    - [Установка CMake](#установка-cmake)
  - [ССылки](#ссылки)

## Задания

- Для получения оценки "удовлетворительно" нужно набрать не менее 120 баллов.
- На оценку хорошо нужно набрать не менее 160 баллов.
- Для получения оценки "отлично" нужно набрать не менее 200 баллов.

### Требования

Обязательно проверяйте успешность всех вызовов функций операционной системы и не оставляйте ошибки незамеченными.

Ваш код должен иметь уровень безопасности исключений не ниже базового.
Для этого разработайте (или возьмите готовую) RAII-обёртку, автоматизирующую
управление ресурсами операционной системы.

### Задание 1 — sys-info-win — 50 баллов

Научиться работать с Windows API для получения системной информации, реализовать структурированный и надёжный C++-код, который:

- Использует RAII для управления ресурсами,
- Обрабатывает все возможные ошибки корректно,
- Даёт студенту понимание, как устроена система "под капотом".

Напишите программу sys-info-win для ОС Windows, которая бы выводила в консоль информацию о компьютере на котором она запущена:

- Версия операционной системы.
  - Используйте IsWindows10OrGreater() и аналоги из VersionHelpers.h
- Размер виртуальной и физической памяти, а также использование памяти в процентах.
- Количество ядер процессора
- Имя компьютера и имя пользователя
- Архитектура процессора (x86, x64, ARM)
- Размер файла подкачки (функция `GetPerformanceInfo`)
- Список логических дисков + их объёмы

#### Пример выводимой информации

```txt
OS: Windows 10 or Greater
Computer Name: DESKTOP-12345
User: Ivan Ivanov
Architecture: x64 (AMD64)
RAM: 6417MB / 7796MB
Virtual Memory: 16000MB
Memory Load: 47%
Pagefile: 20480MB / 32000MB

Processors: 16
Drives:
  - C:\  (NTFS): 114 GB free / 237 GB total
  - D:\  (NTFS): 80 GB free / 100 GB total
```

#### Подсказки

Начиная с Windows 8.1 Microsoft не рекомендует приложениям привязываться к версии операционной системы,
поэтому функции вроде [`GetVersionEx`](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getversionexw)
могут возвращать недостоверную информацию о версии операционной системы.

Используйте [вспомогательные функции Windows](https://learn.microsoft.com/en-us/windows/win32/sysinfo/version-helper-apis),
чтобы узнать информации о версии ОС.
Для получения актуальной информации используйте функцию [RtlGetVersion](https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-rtlgetversion?redirectedfrom=MSDN).

Узнать количество процессоров можно функцией [`GetSystemInfo`](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getsysteminfo)
и [`GetNativeSystemInfo`](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-getnativesysteminfo).

Узнать информацию о памяти компьютера можно функций [`GlobalMemoryStatusEx`](https://learn.microsoft.com/en-us/windows/win32/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex).

Размер файла подкачки можно получить функцией [GetPerformanceInfo](https://learn.microsoft.com/en-us/windows/win32/api/psapi/nf-psapi-getperformanceinfo).

Информацию о дисках можно получить функциями `GetLogicalDriveStrings` и `GetDiskFreeSpaceEx`.

### Задание 2 — sys-info-linux — 50 баллов

Напишите программу sys-info-linux для ОС Linux, которая бы выводила в консоль информацию о компьютере, на котором запущена:

- Версия ядра и дистрибутива
  - Используйте `uname()` для ядра
  - Используйте `lsb_release()` или чтение `/etc/os-release`
- Количество свободной и имеющейся оперативной памяти (в мегабайтах)
  - Используйте `sysinfo` или парсинг `/proc/meminfo`.
- Количество логических процессоров (`get_nprocs()`)
- Архитектура процессора
  - Используйте `uname().machine`
- Загрузка процессора (из sysinfo.loads) или `/proc/loadavg`.
- Список подключенных логических дисков
  - прочитать `/proc/mounts` или вызывать `getmntent`.
  - Получить статистику через `statvfs()`
- Информация о текущем пользователе и hostname
  - `getlogin()`, `gethostname()` или `getpwuid(getuid())`.
- Объём доступной виртуальной памяти
  - Через `/proc/meminfo`, поле `VmallocTotal` (если доступно)

#### Пример выводимой информации

```txt
OS: Ubuntu 22.04.1 LTS
Kernel: Linux 5.15.0-86-generic
Architecture: x86_64
Hostname: dev-machine-01
User: student
RAM: 5983MB free / 7796MB total
Swap: 2047MB total / 512MB free
Virtual memory: 134217 MB
Processors: 16
Load average: 0.12, 0.45, 0.91
Drives:
  /          ext4     40GB free / 100GB total
  /mnt/c     fuse     12GB free / 237GB total
```

### Задание 3 — sys-info-crossplatform — 30 баллов

Разработайте класс `SysInfo`, предоставляющий методы для получения информации о системе из заданий:

- Название и версия ОС
- Количество логических процессоров
- Количество свободной и установленной оперативной памяти

Класс должен быть возможно скомпилировать как под Windows, так и под Linux. Публичный интерфейс класса представлен ниже.

```c++
class SysInfo
{
public:
    std::string GetOSName() const;
    std::string GetOSVersion() const;
    uint64_t GetFreeMemory() const;
    uint64_t GetTotalMemory() const;
    unsigned GetProcessorCount() const;
};
```

Разработайте на основе этого класса консольное приложение **sys-info**, выводящее в консоль информацию о компьютере
и операционной системе.

Для сборки приложения должна использоваться система сборки [CMake](https://cmake.org/).
Приложение должно собираться как под Windows, так и под Linux.

#### Подсказки

- Используйте директивы управления компиляцией `#ifdef`, `#ifndef`, `#else`, `#endif` и другие,
чтобы подключить нужные заголовочные функции и использовать необходимые функции.
Либо используйте отдельные наборы файлов реализаций

### Задание 4 — Знакомство утилитами Linux часть 1 — 40 баллов

Ознакомьтесь с работой некоторых команд Linux.

Чтобы получить инструкцию об использовании той или иной команды, используйте программу `man` (от слова manual).
Для этого в консоли введите:

```bash
man название-команды
```

Например так можно получить инструкцию по команде `cd`:

```bash
man cd
```

Напишите скрипт `solution.sh`, выполняющий следующие действия:

- Архивирует всё содержимое каталога [proj](proj/) в файл `proj.tar.gz`
- Создаёт каталог `out` в текущей директории.
  Если такой каталог уже есть, спрашивает разрешение пользователя пересоздать его.
- Копирует в каталог `out` архив `proj.tar.gz`
- Распаковывает архив в каталоге `out` и удаляет распакованный архив.
- Создаёт подкаталоги `include` и `src` и `build`. Заголовочные файлы перемещает в `include`, а .cpp - в `src`.
- При помощи `g++` скомпилируйте программу (передайте нужные ключи, чтобы директивы `#include` находили файлы).
  - Скомпилированное приложение должен оказаться в каталоге `build`.
- Запустите из скрипта программу, передав ей в stdin числа 30 и 12, а вывод программы перенаправьте в файл stdout.txt.

### Задание 5 —  Знакомство утилитами Linux часть 2 — 60 баллов

- Командой `mkdir` создайте каталог *out*. Если такой каталог уже есть,
то рекурсивно удалите содержимое каталога командой `rm`. Узнать о наличии каталога можно командой `test`.
- Перейдите внутрь каталога *out* командой `cd`.
- Внутри каталога *out* создайте файл *me.txt*, содержимое которого — имя текущего пользователя.
Чтобы узнать имя пользователя, перенаправьте вывод команды `whoami` в соответствующий файл.
- Создайте файл *metoo.txt*, скопировав содержимое файла *me.txt* командой `cp` в файл *metoo.txt*.
- Создайте файл *wchelp.txt*, содержащий документацию о работе команды `wc`.
  - Подсказка: перенаправьте вывод команды `man wc` в соответствующий файл.
- Выведите содержимое файла *wchelp.txt* в консоль, используя команду `cat`.
- Выведите в файл *wchelp-lines.txt* количество строк в файле *wchelp.txt*.
  - Для этого воспользуйтесь командами `wc` и `cut`.
  - Подайте вывод команды `wc` на вход команде `cut`, используя операцию `|`:

    ```sh
    wc параметры-команды-wc | cut параметры-команды-cut >файл-куда-вывести-результат
    ```

- Создайте файл *wchelp-reversed.txt*, содержимое которого составлено из строк файла *wchelp.txt*,
расположенных в обратном порядке.
Для этого воспользуйтесь командой `tac`.
- Создайте файл *all.txt*, содержимое которого составлено из строк файлов:
  *wchelp.txt*, *wchelp-reversed.txt*, *me.txt*, *metoo.txt*, *wchelp-lines.txt*.
  Для объединения содержимого файлов используйте команду `cat`.
- Командой `tar` создайте архив *result.tar*, содержащий все файлы текущего каталога, имеющие расширение *.txt*.
- Командой `gzip` скомпрессируйте *result.tar* в файл *result.tar.gz*.
- Выйдите из каталога *out* в родительский каталог, используя команду `cd`.
- Переместите командой `mv` файл *out/result.tar.gz* в текущий каталог.
  - Предварительно проверьте наличие файла result.tar.gz в текущем каталоге командой `test`.
  - Если такой файл был, удалите его командой `rm` перед перемещением нового файла из каталога *out*.
- Удалите каталог *out* командой `rmdir`.

Результат работы оформите в виде скрипта *solution.sh* со следующим содержимым:

```bash
#!/usr/bin/env bash
# Предыдущая строка сообщает загрузчику программы, что надо использовать оболочку bash

# Если любая из следующих команд завершится неудачей, скрипт прекратит свою работу
set -e

# Тут поместите остальные команды
```

## Настройка системы

### Обновление пакетного менеджера apt

Перед установкой рекомендуется обновить пакетный менеджер apt:

```bash
sudo apt update
```

### Установка компилятора g++

```bash
sudo apt install g++
```

### Установка CMake

```bash
sudo apt install cmake
```

Если работа с Linux происходит под WSL, то для генерирования CMake-проектов проектов нужно явно указать каталоги с исходниками:

```bash
# Предполагается, что в текущей директории содержится файл CMakeLists.txt
mkdir build

cd build

# Явно указываем, что CMakeLists.txt находится в родительском каталоге, а проекты сгенерировать в текущем
cmake -S .. -B .

# Когда Linux запущен не из WSL, предыдущую команду можно заменить на:
cmake ..

# Собираем проект, сгенерированный в текущем каталоге
cmake --build .
```

## ССылки

- [Список Windows API](https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list)
- [Linux man-pages project](https://www.kernel.org/doc/man-pages/) - поисковик по документации ядра Linux.
- [Система сборки CMake](https://cmake.org/).
- [Intel® 64 and IA-32 Architectures Software Developer’s Manual](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
  - Для доступа к сайту используйте VPN либо браузер Tor.
- [Linux Pocket Guide](https://linuxpocketguide.com/)
- [CMake с нуля](https://www.youtube.com/playlist?list=PL6x9Hnsyqn2UwWjSvjCzAY6sEOBrHY7VH) (Плейлист на Youtube)
- Системы сборки make и CMake
  ([YouTube](https://www.youtube.com/watch?v=KPlVqXsXKVA), [RuTube](https://rutube.ru/video/e5b49317d420d580fb04a5da2894b034/))
- Принимаются Pull Request-ы
