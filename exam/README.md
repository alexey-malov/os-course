# Вопросы к экзамену

## Процессы и потоки

- Объясните, чем поток отличается от процесса с точки зрения ресурсов и планирования?
  Какие структуры/объекты у них общие, а какие — индивидуальные?
- Почему потоки называют «лёгкими процессами»? Приведите аргументы «за» и «против» такого термина.
- Опишите жизненный цикл потока. Какие состояния есть у потока бы выделили и почему?
- Расскажите, как устроены стеки потоков.
  Почему у каждого потока свой стек и к каким ошибкам приводит неправильный выбор размера стека?
- Что такое thread-local storage (TLS)? Как оно реализуется на уровне ОС/ABI и компилятора?
  Какие преимущества и издержки у TLS?
- Сравните стоимость доступа к глобальной переменной и к thread_local. От чего зависит реальная производительность в приложениях?
- Что означает «поток — единица планирования, процесс — единица ресурсов»?
  Приведите конкретные примеры, где это разделение важно.
- Чем отличается конкурентность от параллелизма в контексте потоков?
- Приведите пример конкурентной, но не параллельной программы.
- Опишите проблемы, возникающие при совместном доступе потоков к общим данным без синхронизации.
  Что такое гонка данных и data race vs race condition?

- Какие базовые примитивы синхронизации вы знаете (mutex, RWLock, semaphore, condition variable, barrier)? Когда какой уместен?
- Что такое ложное пробуждение (spurious wakeup) и как правильно писать ожидание с условной переменной?
- Объясните разницу между взаимным исключением и линеаризуемостью (linearizability). Зачем программисту понимать второе?
- Опишите deadlock: необходимые условия, типовые сценарии, приёмы предотвращения и обнаружения.
- Что такое livelock и starvation? Приведите пример и объясните, чем они отличаются от deadlock.
- Чем spinlock отличается от mutex? Когда спинлок может быть быстрее, а когда — вреден?
- Объясните понятия fairness и priority inversion. Как ОС и библиотеки борются с инверсией приоритетов?
- Сравните user-level threads и kernel-level threads: плюсы, минусы, характерные области применения.
- Что такое гибридная M:N модель потоков? Какие преимущества и сложности она приносит рантайму/ОС?
- Почему блокирующий системный вызов в модели user-level потоков блокирует «весь процесс»? Как этого избежать на практике?
- Опишите роль планировщика ОС для потоков. Какие политики (например, CFS/основные классы приоритетов) влияют на работу CPU-bound/IO-bound нитей?
- Как page fault влияет на потоки в user-level и kernel-level моделях?
- Объясните различия в доставке сигналов процессу/потокам в POSIX. Как выбирать поток-обработчик?
- Перечислите способы создания потоков в POSIX: pthread_create и ключевые атрибуты (стек, detach, policy). Когда и зачем менять значения по умолчанию?
- Что делает pthread_join и чем detach-поток отличается от joinable? Какие утечки/ошибки возможны при неверном использовании?
- Для чего нужны pthread_atfork в многопроцессной программе, использующей потоки? Когда их стоит применять?
- Сравните CreateThread и _beginthreadex в Windows. Почему во множестве случаев рекомендуется именно _beginthreadex?
- Какие гарантии и требования у потоковой поддержки C/C++ рантайма (errno, локаль, буферы stdio)? Что случится, если их игнорировать?
- Объясните различия std::thread и std::jthread. Какие риски снимает jthread и какой ценой?
- Что такое std::stop_token и как им корректно «останавливать» поток? Чем это лучше «глобального флага»?
- Расскажите о том, как передавать аргументы и возвращаемые значения в потоки C++ (capturing, by value/by reference, сроки жизни, futures/promises/packaged_task).
- Почему важно явно управлять временем жизни потоков (join/detach) в C++? Какие типичные аварии возникают при нарушении этого правила?
- Объясните, как проектировать «владение ресурсами» между потоками: кто закрывает файловый дескриптор, кто удаляет временный файл, кто завершает очередь задач?
- Приведите пример потоко-безопасного логирования. Как избежать перемешивания строк и двойного flush?
- В чём разница между «моделью памяти» языка (C++ memory model) и «моделью памяти» архитектуры CPU? Почему это важно при многопоточности?
- Что такое happens-before? Приведите примеры отношений happens-before в C++ и как их создавать.
- Объясните понятие «атомарных операций» и упорядочиваний (memory_order_seq_cst/acq_rel/relaxed). Когда оправдан relaxed?
- Когда вместо потоков лучше использовать событийную (event-driven) архитектуру с неблокирующим I/O? Какие trade-offs по удобству/производительности?
- Как реализовать конвейер (pipeline) с потоками: постановка задач, очереди, back-pressure, ограничения по памяти/латентности?
- Почему «много маленьких потоков» зачастую хуже пула потоков? Опишите дизайн разумного thread pool.
- Как вы бы бенчмаркировали стоимость переключения контекста между потоками и накладные расходы синхронизации? Что именно измерять и как интерпретировать?
- Приведите пример скрытой общей глобальной зависимости, из-за которой многопоточная программа деградирует (например, общий аллокатор/глобальный кэш). Как диагностировать и лечить?
- Объясните влияние NUMA на многопоточные приложения: привязка потоков (affinity), размещение памяти (first-touch), межузловые задержки.
- Какие стратегии уменьшения ложного совместного использования кэша (false sharing) вы знаете? Покажите на примере структур данных.
- Когда стоит предпочесть read–copy–update (RCU), hazard pointers или epoch-based reclamation вместо классических мьютексов?
- Какие у унаследованных библиотек типичные проблемы с многопоточностью (не-reentrant функции, общие буферы, глобальные синглтоны)? Как вводить изоляцию по шагам?
- Опишите подход к тестированию многопоточного кода: стресс-тесты, фазы с инъекцией задержек, sanitizer’ы (ThreadSanitizer), детерминизация.
- Вы разрабатываете кроссплатформенную библиотеку: где проводить «границу абстракции» между std::thread/jthread и платформенными API (pthread, _beginthreadex)? Обоснуйте архитектурно.
- Представьте, что у вас есть приложение с интенсивным I/O и периодическими тяжёлыми вычислениями. Сравните три дизайна: «много потоков», «пул + неблокирующий I/O», «событийная петля + worker pool». Обоснуйте выбор под разные профили нагрузки и ограничения (память, tail latency, простота сопровождения).
