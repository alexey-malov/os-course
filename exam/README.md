# Вопросы к экзамену

- [Вопросы к экзамену](#вопросы-к-экзамену)
  - [Общие сведения об ОС](#общие-сведения-об-ос)
  - [Процессы/переключение контекста и регистры, режимы процессора](#процессыпереключение-контекста-и-регистры-режимы-процессора)
  - [Память, виртуальная память и MMU, шины](#память-виртуальная-память-и-mmu-шины)
  - [Базовые абстракции ОС: процессы, адресные пространства, файлы](#базовые-абстракции-ос-процессы-адресные-пространства-файлы)
  - [Пользователи, UID/GID и модель прав](#пользователи-uidgid-и-модель-прав)
  - [Адресное пространство и аппаратная защита](#адресное-пространство-и-аппаратная-защита)
  - [Файловые системы: пути, каталоги, операции](#файловые-системы-пути-каталоги-операции)
  - [Базовые понятия: процесс, программа, абстракция ОС, параллелизм](#базовые-понятия-процесс-программа-абстракция-ос-параллелизм)
  - [Создание процессов: UNIX fork/exec и Windows CreateProcess](#создание-процессов-unix-forkexec-и-windows-createprocess)
  - [Идентификаторы и дескрипторы, управление процессами](#идентификаторы-и-дескрипторы-управление-процессами)
  - [Классическая модель потока](#классическая-модель-потока)
  - [Параллелизм и планирование, ресурсы потока](#параллелизм-и-планирование-ресурсы-потока)
  - [Жизненный цикл потоков и базовые примитивы](#жизненный-цикл-потоков-и-базовые-примитивы)
  - [Процессы и потоки](#процессы-и-потоки)


## Общие сведения об ОС

- Дайте определение операционной системы и объясните, какие задачи она решает в современном компьютере. ⭐
- Почему прикладные программы обычно не работают напрямую с «железом»? Какие проблемы возникли бы без ОС? ⭐⭐
- Объясните, как ОС управляет ресурсами при многопользовательской работе. Какие типы конфликтов она предотвращает? ⭐⭐
- Что такое мультиплексирование во времени и в пространстве? Приведите по 2 примера каждого. ⭐⭐
- В каких типах устройств ОС может быть не нужна? Приведите примеры и объясните почему. ⭐⭐
- Чем RTOS отличается от «полноценной» ОС общего назначения? В каких областях RTOS критична? ⭐⭐
- Опишите базовую архитектуру ПК (CPU–память–I/O) и роль системной шины в этой модели. ⭐
- Что означает, что ОС «создаёт абстракции»? Приведите пример перехода от «блоков диска» к «файлам». ⭐⭐
- Что такое драйвер устройства и почему драйверы часто выполняются в режиме ядра? ⭐⭐
- Назовите и сравните три способа установки драйверов (пересборка ядра, загрузка при старте, hotplug). ⭐⭐
- Что такое прерывание (interrupt) и зачем оно нужно при вводе-выводе? Опишите путь от устройства до обработчика. ⭐⭐⭐
- Сравните методы I/O: busy waiting, interrupts, DMA — плюсы/минусы и типичные сценарии использования. ⭐⭐⭐
- Опишите процесс загрузки компьютера: что делает BIOS/UEFI, как выбирается загрузчик и что происходит при запуске ядра ОС. ⭐⭐⭐
- Сравните BIOS и UEFI (MBR vs GPT/ESP, ограничения, возможности). Почему UEFI считают «маленькой ОС»? ⭐⭐⭐

## Процессы/переключение контекста и регистры, режимы процессора

- Что такое context switch и почему при нём важно сохранять/восстанавливать состояние процессора? ⭐⭐
- Какие регистры процессора важны для ОС (PC, SP, PSW) и как ОС использует/учитывает их? ⭐⭐
- Чем архитектура процессора отличается от микроархитектуры? Почему ОС в основном «видит» архитектуру? ⭐⭐
- Объясните, что такое конвейер (pipeline) и как он повышает производительность. Какие сложности он создаёт? ⭐⭐⭐
- Что такое суперскалярный процессор и «внеочередное выполнение»? Почему это может быть важно для ОС? ⭐⭐⭐
- Сравните kernel mode и user mode: какие инструкции/возможности доступны в каждом режиме и почему? ⭐⭐
- Что такое системный вызов (syscall) и чем он отличается от обычного вызова функции? Опишите общий механизм «trap в ядро». ⭐⭐⭐
- Какие бывают аппаратные traps (кроме syscall)? Как ОС может реагировать на исключительные ситуации? ⭐⭐

## Память, виртуальная память и MMU, шины

- Как ОС управляет памятью при одновременной работе нескольких программ? Какие цели преследуются (справедливость/защита/безопасность)? ⭐⭐
- Что такое виртуальная память и зачем она нужна? Опишите идею «RAM как кэш для диска/SSD». ⭐⭐
- Какова роль MMU? Что означает «преобразование виртуальных адресов в физические»? ⭐⭐⭐
- Что такое кэш CPU (L1/L2/L3)? Объясните термины cache hit и cache miss и влияние на производительность. ⭐⭐
- Приведите примеры кэширования в ОС (не в железе) и объясните, почему это ускоряет систему. ⭐⭐
- Сравните HDD и SSD: как устроены, почему HDD медленнее при случайном доступе, и что усложняет запись в SSD. ⭐⭐
- Что такое «шина» в архитектуре компьютера? Почему современные системы используют несколько шин вместо одной? ⭐⭐
- Чем PCIe принципиально отличается от старых параллельных общих шин (PCI/ISA)? Как масштабирование по линиям влияет на скорость? ⭐⭐⭐

## Базовые абстракции ОС: процессы, адресные пространства, файлы

- Почему в ОС вообще нужны абстракции (процессы/адресные пространства/файлы), и какие проблемы «железа» они скрывают от программиста? ⭐⭐
- Чем «программа» отличается от «процесса», и какие атрибуты превращают код на диске в выполняющийся процесс? ⭐
- Как адресное пространство помогает одновременно в удобстве программирования и в безопасности? ⭐⭐
- Приведите пример: какая одна и та же операция может выглядеть «как работа с файлом», но на самом деле быть работой с устройством или IPC? Объясните идею унификации. ⭐⭐
- Какие последствия для дизайна ОС возникают из того, что процесс и файл — ключевые универсальные абстракции почти во всех ОС? ⭐⭐⭐
- Что именно хранит ОС о процессе в «таблице процессов», и зачем там нужны значения регистров и позиции в файлах? ⭐⭐
- Какие ресурсы (кроме памяти) обычно «прикреплены» к процессу, и что должно случиться с ними при завершении процесса? ⭐⭐
- Опишите, что должно произойти при приостановке и последующем возобновлении процесса, чтобы программа «ничего не заметила». ⭐⭐
- Как вы объясните различие между состоянием «спит», «выполняется», «остановлен», «зомби» с точки зрения ОС и родителя процесса? ⭐⭐
- Почему процессы часто называют «контейнерами выполнения», и в каком смысле это похоже/не похоже на контейнеры уровня Docker? ⭐⭐⭐
- Какие выводы о системе можно сделать по списку процессов `ps aux`: что искать в USER/PID/STAT/COMMAND? ⭐
- Чем отличаются VSZ/VIRT и RSS/RES, и почему «много VIRT» не всегда означает «проблема с памятью»? ⭐⭐
- Как интерпретировать %CPU в `top` на многоядерной машине: когда 100% — это «всё» и когда — «одно ядро»? ⭐⭐
- Что означает load average, и почему он может быть высоким даже при низком %CPU? ⭐⭐⭐
- Как бы вы нашли «подозрительный» процесс, который редко использует CPU, но постоянно держит диск занятым? Какие поля/инструменты помогут? ⭐⭐⭐
- Почему в UNIX-подобных системах естественно возникает дерево процессов? Что даёт модель «родитель–ребёнок»? ⭐⭐
- Сравните: IPC через каналы (pipes), через файлы и через сокеты — в чём различие по модели использования и по стоимости? ⭐⭐⭐
- Что такое сигнал: чем он принципиально отличается от «сообщения» IPC, и почему его сравнивают с прерываниями? ⭐⭐
- Придумайте сценарий, где сигнал — хороший механизм (например, таймер/ошибка), и сценарий, где сигнал — плохой выбор и лучше IPC. ⭐⭐⭐
- Что может пойти не так, если процесс «не готов» принимать сигнал (нет обработчика) — почему это иногда полезно, а иногда опасно? ⭐⭐

## Пользователи, UID/GID и модель прав

- Зачем ОС связывает процесс с UID/GID, и как это влияет на доступ к файлам и процессам других пользователей? ⭐⭐
- Чем отличается «пользователь» от «группы» в практическом управлении доступом? Приведите пример политики доступа. ⭐⭐
- Почему root (администратор) — одновременно полезная и опасная концепция? Какие риски она создаёт? ⭐⭐
- Какую информацию можно извлечь из `/etc/passwd`, и почему наличие записи там ещё не означает возможность интерактивного входа? ⭐⭐⭐
- Опишите типичную модель «минимально необходимых прав» и как она реализуется на практике в UNIX через пользователей/группы/права. ⭐⭐⭐
- В чём принципиальная разница между `su` и `sudo` с точки зрения модели безопасности? ⭐⭐
- Почему `su` считается менее безопасным подходом в командах/организациях, и как это связано с паролями и аудитом? ⭐⭐
- Что именно меняется при `su`: какие части «сессии» (окружение, текущий каталог, права) могут вести себя иначе? ⭐⭐⭐
- Зачем `sudo` обычно просит пароль текущего пользователя, а не root? Как это помогает контролю и расследованиям? ⭐⭐
- Опишите сценарий, когда `sudo` может быть опасен при неверной настройке (например, чрезмерные права), и как это предотвратить. ⭐⭐⭐

## Адресное пространство и аппаратная защита

- Что такое адресное пространство процесса, и почему «несколько процессов в памяти» требуют аппаратной поддержки? ⭐⭐
- Как процессор и ОС вместе обеспечивают, что процесс не может читать/писать память другого процесса? (Опишите на уровне идеи.) ⭐⭐⭐
- Что такое режим пользователя и режим ядра, и почему системные вызовы требуют перехода между ними? ⭐⭐
- Почему ранние системы могли обходиться без защиты памяти, и какие компромиссы это накладывало на надёжность? ⭐⭐
- Почему во встраиваемых системах защита памяти иногда отсутствует и сегодня: когда это оправдано, а когда — нет? ⭐⭐⭐
- Объясните идею виртуальной памяти: какие иллюзии она создаёт для процесса и какие задачи решает для ОС? ⭐⭐
- Что такое swap и в каких случаях его использование помогает, а в каких — «убивает» производительность? ⭐⭐
- Как связаны «страницы памяти», подкачка и то, что программа может адресовать больше, чем физическая RAM? ⭐⭐⭐
- Как бы вы интерпретировали вывод `free -h` и `vmstat`: какие поля укажут на активную подкачку и дефицит памяти? ⭐⭐⭐
- Почему виртуальная память упрощает код прикладных программ, а не только «даёт больше памяти»? Приведите пример. ⭐⭐⭐

## Файловые системы: пути, каталоги, операции

- Почему файловая система считается ключевой абстракцией ОС, и какие детали устройств она скрывает? ⭐⭐
- Объясните разницу между абсолютным и относительным путём и роль текущего рабочего каталога процесса. ⭐
- Как устроена иерархия каталогов как «дерево», и какие преимущества даёт по сравнению с одноуровневой директорией? ⭐⭐
- Почему операции `open/read/write/close` считаются «минимальным набором» для работы с данными? Что строится поверх них? ⭐⭐
- Чем отличается удаление файла от удаления каталога (`rm` vs `rmdir`), и почему каталог нельзя удалить, пока он не пуст? ⭐⭐
- Что такое монтирование и почему модель «единое дерево» отличается от «букв дисков» в Windows? ⭐⭐
- Объясните роль `/dev` и смысл «специальных файлов»: что это даёт ОС и приложениям? ⭐⭐
- Что такое pipe в терминах потока данных: почему он выглядит как файл, но ведёт себя иначе? ⭐⭐
- Зачем существуют `/dev/stdout` и `/dev/null`: какие практические сценарии они упрощают? ⭐

## Базовые понятия: процесс, программа, абстракция ОС, параллелизм

- Что такое **процесс** с точки зрения операционной системы, и какие компоненты состояния отличают его от «просто программы на диске»? ⭐
- Объясните разницу между понятиями **программа** и **процесс** на примере одного исполняемого файла, запущенного несколько раз. ⭐
- Почему процесс называют **ключевой абстракцией ОС**, и какие механизмы ОС вокруг него построены? ⭐⭐
- Что означает идея **«виртуального CPU»** для процесса, и за счёт чего ОС создаёт эту иллюзию? ⭐⭐
- Какие ресурсы процесса можно считать **логическими**, а какие — **физическими**, и как ОС разделяет эти уровни? ⭐⭐⭐
- Какие свойства процесса делают его удобной единицей **изоляции и безопасности** в системе? ⭐⭐
- В каких случаях процессы в системе **не являются пользовательскими программами**, а служат инфраструктурой ОС? ⭐⭐
- Объясните, что такое **псевдопараллелизм** на одном ядре и почему пользователь воспринимает его как «одновременность». ⭐
- Чем принципиально отличается псевдопараллелизм от **реального параллелизма** на многоядерной системе? ⭐
- Почему в многозадачной системе **скорость выполнения** отдельного процесса становится плохо предсказуемой? ⭐⭐
- Почему **busy-wait / idle loops** — плохой способ тайминга в ОС с вытесняющей многозадачностью? ⭐⭐
- Какие механизмы нужны системе, чтобы поддерживать задачи **реального времени**, и почему «обычное планирование» часто не подходит? ⭐⭐⭐
- Как мультипрограммирование связано с тем, что процессы часто находятся в состоянии **ожидания I/O**? ⭐⭐

## Создание процессов: UNIX fork/exec и Windows CreateProcess

- Перечислите основные ситуации, когда в системе **создаются процессы** (boot, пользователь, родитель, batch) и объясните их отличия. ⭐
- Почему в UNIX исторически сложилась двухшаговая модель **fork() → exec()**, и какие преимущества она даёт? ⭐⭐
- Что именно копирует fork() и что **не копируется**? ⭐⭐
- Что такое **copy-on-write** и почему он делает fork эффективным в реальных ОС? ⭐⭐⭐
- В чём смысл «окна» между fork() и exec() для shell-подобных программ? Приведите примеры действий, которые выполняются именно там. ⭐⭐
- Что делает execve()/execvp() на уровне процесса, и почему говорят «заменяет образ процесса»? ⭐⭐
- Почему в Windows используют **CreateProcess** вместо fork/exec, и какие возможности он даёт сразу при запуске? ⭐⭐
- Какие типичные ошибки делают при работе с CreateProcess (например, командная строка, наследование дескрипторов, ожидание завершения)? ⭐⭐⭐
- Объясните, зачем родителю ждать дочерний процесс (waitpid / WaitForSingleObject), и что может случиться, если этого не делать. ⭐⭐
- Какие бывают причины завершения процесса и чем отличается «ошибка программы» от «принудительного убийства»? ⭐
- Чем отличается **exit-код** процесса от завершения **сигналом**, и почему ОС должна уметь различать эти сценарии? ⭐⭐
- Как родитель в UNIX может определить: ребёнок завершился нормально или был убит сигналом? ⭐⭐
- Что означает «завершение родителя ≠ завершение детей» и какие последствия это имеет для архитектуры сервисов? ⭐⭐
- Почему в многопользовательской системе нельзя разрешать «кому угодно» завершать чужие процессы? Какие механизмы авторизации обычно применяются? ⭐⭐⭐
- Почему fork в C++ может «ломать» привычный жизненный цикл объектов, и какие классы проблем это порождает? ⭐⭐
- Объясните разницу между `exit()` и `_exit()` в дочернем процессе после fork, и почему неправильный выбор может приводить к багам. ⭐⭐⭐
- Приведите примеры ресурсов (файлы, сокеты, lock-файлы, логи), которые после fork могут привести к ошибкам, и предложите стратегии безопасного дизайна. ⭐⭐⭐

## Идентификаторы и дескрипторы, управление процессами

- Что такое PID и какие свойства у него есть (уникальность, переиспользование, область видимости)? ⭐
- В чём отличие PID от HANDLE: почему PID — это «паспорт», а HANDLE — «ключ»? ⭐⭐
- Какие операции обычно можно выполнить, имея только PID, и какие требуют более «сильной ссылки» на объект? ⭐⭐
- Почему в Windows объект ядра может продолжать существовать после завершения процесса, и что определяет момент его уничтожения? ⭐⭐⭐
- Объясните, как в Linux соотносятся PID, TID и TGID, и почему главный поток имеет PID = TID. ⭐⭐
- Как формируется **дерево процессов** в UNIX, и почему процесс PID 1 играет особую роль? ⭐⭐
- Что такое процесс-группа и зачем она нужна в терминальной работе (например, Ctrl-C)? ⭐⭐
- Почему говорят, что Windows «не хранит дерево процессов так же жёстко», как UNIX, и какие практические последствия у этого есть? ⭐⭐
- Что такое «потеря иерархии» при передаче HANDLE другому процессу в Windows, и почему это меняет модель управления? ⭐⭐⭐
- Опишите модель состояний процесса: **Running / Ready / Blocked**. Что означает каждое состояние на практике? ⭐
- Разберите переходы между состояниями: какие из них вызваны **внешними событиями**, а какие — решениями **планировщика**? ⭐⭐
- Почему процесс может быть Ready, но не Running, и какие факторы влияют на то, когда он получит CPU? ⭐⭐
- На примере pipeline `cat | grep` объясните, почему один процесс может быть Blocked, а другой — Running/Ready, и как это связано с I/O. ⭐⭐
- Чем отличается блокировка на I/O от «просто ожидания кванта времени» с точки зрения эффективности системы? ⭐⭐⭐
- Что такое **PCB (Process Control Block)** и какие данные в нём критичны для переключения контекста? ⭐⭐
- Почему таблица процессов — это не просто список, а центральная структура для планировщика, сигналов, памяти и файлов? ⭐⭐⭐
- Опишите, что происходит при **переключении контекста**: какие части состояния сохраняются и где именно. ⭐⭐⭐
- Почему процесс может быть прерван тысячи раз, но «не замечать этого»? Какие условия должны соблюдаться для этой иллюзии? ⭐⭐
- Как связаны понятия **прерывание**, **обработчик**, **вектор прерываний** и последующее решение планировщика? ⭐⭐⭐
- Что такое `task_struct` в Linux и почему его считают «сердцем» модели процессов? ⭐⭐⭐

## Классическая модель потока

- Чем поток принципиально отличается от процесса с точки зрения модели ОС и программиста? ⭐
- Почему потоки называют «процессом внутри процесса» — что именно “внутри”, а что “общее”? ⭐⭐
- Какие типы задач выигрывают от потоков, а какие — почти не выигрывают? Приведите примеры. ⭐⭐
- Объясните идею перекрытия I/O и вычислений на примере: что означает «CPU не простаивает»? ⭐⭐
- Почему создание/уничтожение потоков обычно дешевле, чем процессов? За счёт каких ресурсов/операций? ⭐⭐
- В каких случаях многопоточность может ухудшить производительность по сравнению с однопоточной программой? ⭐⭐⭐
- Какие сущности относятся к «ресурсам процесса», а какие — к «контексту исполнения потока»? ⭐
- Почему процесс называют «единицей управления ресурсами», а поток — «единицей планирования»? ⭐⭐
- Какие ресурсы *обычно* общие для потоков одного процесса, а какие — строго индивидуальные? ⭐⭐
- Что именно хранится в «контексте потока», который требуется для переключения? ⭐⭐
- Как наличие общего адресного пространства упрощает взаимодействие потоков по сравнению с процессами? ⭐
- Почему отсутствие защиты между потоками делает ошибки опаснее, чем при IPC между процессами? ⭐⭐

## Параллелизм и планирование, ресурсы потока

- Чем псевдопараллелизм на одном CPU отличается от реального параллелизма на многоядерной системе? ⭐
- Как ОС решает, какой поток получит CPU следующим (в общих чертах)? ⭐⭐
- Что означают состояния running/ready/blocked/terminated для *потока*, и как они соотносятся с состояниями процессов? ⭐⭐
- Приведите пример перехода thread: running → blocked и объясните, почему это не «ошибка планировщика». ⭐⭐
- В каких ситуациях полезен добровольный yield, и почему он не гарантирует немедленного переключения? ⭐⭐
- Какие метрики/сигналы в системе вы бы смотрели, чтобы понять: приложение ограничено CPU или I/O? ⭐⭐⭐
- Почему у каждого потока должен быть собственный стек? Что сломается при «общем стеке»? ⭐⭐
- Что такое «кадры стека» и почему их структура важна для понимания выполнения потока? ⭐
- Какие данные разделяются потоками в куче/глобальной области, а какие — «живут» на стеке каждого потока? ⭐⭐
- Приведите пример ошибки, когда адрес локальной переменной передают в поток, и объясните причину. ⭐⭐
- Как различается типичная отладка багов «повреждение стека» vs «гонка данных» (на уровне симптомов)? ⭐⭐⭐
- Что означает «ядро не в курсе потоков» в user-level модели, и как библиотека переключает потоки? ⭐⭐
- Почему блокирующий системный вызов (например, read) блокирует **весь процесс** при user-level threads? ⭐⭐
- Почему page fault в user-level модели может «заморозить» все user threads, даже если они логически независимы? ⭐⭐⭐
- Какие обходные решения позволяют делать user-level потоки практичнее (select/poll/epoll, wrapper’ы), и чем они платят? ⭐⭐⭐
- В чём ключевые преимущества kernel threads над user-level threads, и какие накладные расходы они добавляют? ⭐⭐
- Объясните гибридную модель M:N: что планирует ОС, что планирует рантайм, и почему это похоже на goroutines/виртуальные потоки. ⭐⭐⭐

## Жизненный цикл потоков и базовые примитивы

- Опишите типичный жизненный цикл: create → работа → join. Какие ошибки бывают на каждом этапе? ⭐⭐
- Что произойдёт, если не вызвать join/detach для std::thread, и почему стандарт выбрал именно такое поведение? ⭐⭐
- Чем joinable поток отличается от detached (концептуально и по последствиям для ресурсов)? ⭐⭐
- Какие стратегии завершения потоков вы бы применили в сервере: «жёстко убить», «кооперативно остановить», «дождаться» — и почему? ⭐⭐⭐
- Почему важно проектировать «владение задачей» и «владение потоком» отдельно? ⭐⭐⭐
- Объясните назначение pthread_create: какие параметры критичны и почему start_routine имеет сигнатуру void* (void*)? ⭐⭐
- Почему нельзя передавать &i (адрес переменной цикла) как arg в pthread_create? Объясните, когда это «случайно работает». ⭐⭐
- Что делает pthread_join, и какие типичные ошибки приводят к EINVAL/EDEADLK/ESRCH? ⭐⭐⭐
- Зачем существуют pthread_attr_* и какие атрибуты вы бы реально настраивали в практике? ⭐⭐
- Что такое размер стека потока, чем опасен слишком маленький стек, и почему есть PTHREAD_STACK_MIN? ⭐⭐
- Когда вы бы использовали sched_yield, и почему он не является «средством синхронизации»? ⭐⭐
- Почему для программ с C/C++ runtime в Windows рекомендуют _beginthreadex, а не CreateThread? ⭐⭐
- Какие проблемы могут проявиться при CreateThread в программе, активно использующей CRT (printf/malloc/iostream), и почему? ⭐⭐⭐
- Зачем CloseHandle после завершения потока и почему его не делает _endthreadex? ⭐⭐
- Чем отличается HANDLE от thread id (TID) с точки зрения управления потоком? ⭐⭐
- Как бы вы организовали ожидание нескольких потоков в Windows и какие ограничения/нюансы у WaitForMultipleObjects? ⭐⭐⭐
- Сравните std::thread и std::jthread: какие риски снижает jthread и какой ценой? ⭐⭐
- Почему «RAII для потока» в виде std::jthread — важная идея для надёжности? ⭐⭐
- Объясните идею кооперативной отмены через std::stop_token: что должно делать тело потока? ⭐⭐
- Что произойдёт в примере с SortVector, если **не сохранять** возвращаемый std::jthread в переменную? Почему? ⭐⭐⭐
- В каких случаях вы бы предпочли std::thread вместо std::jthread (если вообще)? ⭐⭐⭐

## Процессы и потоки

- Объясните, чем поток отличается от процесса с точки зрения ресурсов и планирования?
  Какие структуры/объекты у них общие, а какие — индивидуальные?
- Почему потоки называют «лёгкими процессами»? Приведите аргументы «за» и «против» такого термина.
- Опишите жизненный цикл потока. Какие состояния есть у потока бы выделили и почему?
- Расскажите, как устроены стеки потоков.
  Почему у каждого потока свой стек и к каким ошибкам приводит неправильный выбор размера стека?
- Что такое thread-local storage (TLS)? Как оно реализуется на уровне ОС/ABI и компилятора?
  Какие преимущества и издержки у TLS?
- Сравните стоимость доступа к глобальной переменной и к thread_local. От чего зависит реальная производительность в приложениях?
- Что означает «поток — единица планирования, процесс — единица ресурсов»?
  Приведите конкретные примеры, где это разделение важно.
- Чем отличается конкурентность от параллелизма в контексте потоков?
- Приведите пример конкурентной, но не параллельной программы.
- Опишите проблемы, возникающие при совместном доступе потоков к общим данным без синхронизации.
  Что такое гонка данных и data race vs race condition?

- Какие базовые примитивы синхронизации вы знаете (mutex, RWLock, semaphore, condition variable, barrier)? Когда какой уместен?
- Что такое ложное пробуждение (spurious wakeup) и как правильно писать ожидание с условной переменной?
- Объясните разницу между взаимным исключением и линеаризуемостью (linearizability). Зачем программисту понимать второе?
- Опишите deadlock: необходимые условия, типовые сценарии, приёмы предотвращения и обнаружения.
- Что такое livelock и starvation? Приведите пример и объясните, чем они отличаются от deadlock.
- Чем spinlock отличается от mutex? Когда спинлок может быть быстрее, а когда — вреден?
- Объясните понятия fairness и priority inversion. Как ОС и библиотеки борются с инверсией приоритетов?
- Сравните user-level threads и kernel-level threads: плюсы, минусы, характерные области применения.
- Что такое гибридная M:N модель потоков? Какие преимущества и сложности она приносит рантайму/ОС?
- Почему блокирующий системный вызов в модели user-level потоков блокирует «весь процесс»? Как этого избежать на практике?
- Опишите роль планировщика ОС для потоков. Какие политики (например, CFS/основные классы приоритетов) влияют на работу CPU-bound/IO-bound нитей?
- Как page fault влияет на потоки в user-level и kernel-level моделях?
- Объясните различия в доставке сигналов процессу/потокам в POSIX. Как выбирать поток-обработчик?
- Перечислите способы создания потоков в POSIX: pthread_create и ключевые атрибуты (стек, detach, policy). Когда и зачем менять значения по умолчанию?
- Что делает pthread_join и чем detach-поток отличается от joinable? Какие утечки/ошибки возможны при неверном использовании?
- Для чего нужны pthread_atfork в многопроцессной программе, использующей потоки? Когда их стоит применять?
- Сравните CreateThread и _beginthreadex в Windows. Почему во множестве случаев рекомендуется именно _beginthreadex?
- Какие гарантии и требования у потоковой поддержки C/C++ рантайма (errno, локаль, буферы stdio)? Что случится, если их игнорировать?
- Объясните различия std::thread и std::jthread. Какие риски снимает jthread и какой ценой?
- Что такое std::stop_token и как им корректно «останавливать» поток? Чем это лучше «глобального флага»?
- Расскажите о том, как передавать аргументы и возвращаемые значения в потоки C++ (capturing, by value/by reference, сроки жизни, futures/promises/packaged_task).
- Почему важно явно управлять временем жизни потоков (join/detach) в C++? Какие типичные аварии возникают при нарушении этого правила?
- Объясните, как проектировать «владение ресурсами» между потоками: кто закрывает файловый дескриптор, кто удаляет временный файл, кто завершает очередь задач?
- Приведите пример потоко-безопасного логирования. Как избежать перемешивания строк и двойного flush?
- В чём разница между «моделью памяти» языка (C++ memory model) и «моделью памяти» архитектуры CPU? Почему это важно при многопоточности?
- Что такое happens-before? Приведите примеры отношений happens-before в C++ и как их создавать.
- Объясните понятие «атомарных операций» и упорядочиваний (memory_order_seq_cst/acq_rel/relaxed). Когда оправдан relaxed?
- Когда вместо потоков лучше использовать событийную (event-driven) архитектуру с неблокирующим I/O? Какие trade-offs по удобству/производительности?
- Как реализовать конвейер (pipeline) с потоками: постановка задач, очереди, back-pressure, ограничения по памяти/латентности?
- Почему «много маленьких потоков» зачастую хуже пула потоков? Опишите дизайн разумного thread pool.
- Как вы бы бенчмаркировали стоимость переключения контекста между потоками и накладные расходы синхронизации? Что именно измерять и как интерпретировать?
- Приведите пример скрытой общей глобальной зависимости, из-за которой многопоточная программа деградирует (например, общий аллокатор/глобальный кэш). Как диагностировать и лечить?
- Объясните влияние NUMA на многопоточные приложения: привязка потоков (affinity), размещение памяти (first-touch), межузловые задержки.
- Какие стратегии уменьшения ложного совместного использования кэша (false sharing) вы знаете? Покажите на примере структур данных.
- Когда стоит предпочесть read–copy–update (RCU), hazard pointers или epoch-based reclamation вместо классических мьютексов?
- Какие у унаследованных библиотек типичные проблемы с многопоточностью (не-reentrant функции, общие буферы, глобальные синглтоны)? Как вводить изоляцию по шагам?
- Опишите подход к тестированию многопоточного кода: стресс-тесты, фазы с инъекцией задержек, sanitizer’ы (ThreadSanitizer), детерминизация.
- Вы разрабатываете кроссплатформенную библиотеку: где проводить «границу абстракции» между std::thread/jthread и платформенными API (pthread, _beginthreadex)? Обоснуйте архитектурно.
- Представьте, что у вас есть приложение с интенсивным I/O и периодическими тяжёлыми вычислениями. Сравните три дизайна: «много потоков», «пул + неблокирующий I/O», «событийная петля + worker pool». Обоснуйте выбор под разные профили нагрузки и ограничения (память, tail latency, простота сопровождения).
